{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"\ud83c\udfc6 Rank Torrent Name \ud83c\udfc6 <p> Elevate Your Torrent Game </p> <p>Rank Torrent Name (RTN) is a powerful Python library that revolutionizes the way you handle torrent names. With its advanced parsing and customizable ranking system, RTN empowers users to effortlessly filter and prioritize torrents based on their specific preferences.</p> <p>\ud83d\udca1 RTN serves as a comprehensive Version and Ranking System, perfect for parsing and scoring scraped torrent results with precision and flexibility.</p>"},{"location":"#key-features","title":"\ud83c\udf1f Key Features","text":"<ul> <li>\ud83d\udd0d Smart Torrent Parsing: Leverages Parsett for in-depth metadata extraction and enhancement.</li> <li>\ud83c\udfc6 Customizable Ranking: Tailor your torrent selection criteria with user-defined preferences for quality, resolution, audio, and more.</li> <li>\ud83c\udfaf Precision Filtering: Easily set requirements, exclusions, and preferences to pinpoint your ideal torrents.</li> <li>\ud83d\udcca Flexible Ranking Model: Utilize the default model or create your own to match your unique needs.</li> <li>\ud83d\udd24 Title Accuracy Check: Employs Levenshtein Ratio Comparison to ensure parsed titles match originals.</li> </ul>"},{"location":"#core-functionality","title":"\ud83d\udee0\ufe0f Core Functionality","text":"<p>RTN offers a comprehensive toolkit for torrent management:</p> <ul> <li>Parsing: Decode torrent names with advanced algorithms.</li> <li>Ranking: Evaluate torrents based on your custom criteria.</li> <li>Extensibility: Leverage submodules for enhanced capabilities.</li> <li>Utility Functions: Streamline data fetching and sorting processes.</li> </ul>"},{"location":"#module-overview","title":"\ud83d\udcda Module Overview","text":""},{"location":"#main-components","title":"Main Components","text":"<ul> <li><code>RTN</code>: The central class for parsing and ranking operations.</li> <li><code>Torrent</code>: Data structure for parsed torrent information.</li> <li><code>parse</code>: Functions for individual torrent parsing.</li> <li><code>DefaultRanking</code>: Standard model for torrent rank calculation.</li> <li><code>ParsedData</code>: Structured storage for parsed torrent details.</li> </ul>"},{"location":"#essential-models-for-ranking","title":"Essential Models for Ranking","text":"<ul> <li><code>SettingsModel</code>: Customizable user preferences storage.</li> <li><code>BaseRankingModel</code>: Foundation for torrent rank calculations.</li> </ul>"},{"location":"#submodules","title":"Submodules","text":"<ul> <li><code>models</code>: Additional data structures for ranking.</li> <li><code>parser</code>: Enhanced parsing tools.</li> <li><code>patterns</code>: Expanded parsing pattern utilities.</li> <li><code>ranker</code>: Advanced ranking functionalities.</li> <li><code>fetch</code>: Data retrieval and validation utilities.</li> <li><code>exceptions</code>: Custom error handling mechanisms.</li> </ul>"},{"location":"#extra-utilities","title":"Extra Utilities","text":"<ul> <li><code>get_rank</code>: Calculate parsed data rankings.</li> <li><code>check_fetch</code>: Determine torrent fetch eligibility.</li> <li><code>trash_handler</code>: Identify and filter low-quality torrents.</li> <li><code>title_match</code>: Accurate torrent title comparison.</li> <li><code>sort_torrents</code>: Rank-based torrent sorting.</li> <li><code>parse_extras</code>: Extract additional torrent metadata.</li> <li><code>episodes_from_season</code>: Generate episode titles for entire seasons.</li> </ul> <p>\ud83d\udcd8 For a deeper dive, check out our Getting Started guide for users or the Developers section for technical insights.</p>"},{"location":"contributing/","title":"Contributing to Rank Torrent Name (RTN)","text":"<p>We're thrilled you're considering contributing to RTN! This comprehensive guide will walk you through the process of setting up your development environment, making changes, and submitting your contributions. By participating, you agree to adhere to our community norms and code of conduct.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li> <p>Fork and Clone the Repository:    Start by forking the RTN repository on GitHub. Then, clone your fork locally:    <pre><code>git clone https://github.com/YOUR_USERNAME/rank-torrent-name.git\ncd rank-torrent-name\n</code></pre></p> </li> <li> <p>Install Poetry:    RTN uses Poetry for dependency management. If you haven't already, install Poetry by following the official installation guide. Poetry provides a consistent and isolated environment for development.</p> </li> <li> <p>Install Project Dependencies:    With Poetry installed, set up your development environment:    <pre><code>poetry install --with dev\n</code></pre>    This command creates a virtual environment and installs all necessary dependencies, including development tools.</p> </li> <li> <p>Activate the Virtual Environment:    To work within the project's virtual environment, run:    <pre><code>poetry shell\n</code></pre></p> </li> </ol>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a New Branch:    Always create a new branch for your changes:    <pre><code>git switch -c feature/your-feature-name\n</code></pre>    Use a descriptive branch name that reflects the nature of your changes.</p> </li> <li> <p>Implement Your Changes:    Make your desired changes to the codebase. Be sure to:</p> </li> <li>Follow the project's coding style and conventions.</li> <li>Write clear, commented code where necessary.</li> <li>Update or add tests to cover your changes.</li> <li>Update documentation if you're introducing new features or changing existing functionality.</li> </ol>"},{"location":"contributing/#testing-and-quality-assurance","title":"Testing and Quality Assurance","text":"<p>Before submitting your changes, ensure they meet our quality standards:</p> <ol> <li> <p>Run Tests:    <pre><code>make test\n</code></pre>    This command runs the project's test suite. All tests should pass before you submit your changes.</p> </li> <li> <p>Check Code Style:    <pre><code>make lint\n</code></pre>    This runs our linting tools to ensure your code adheres to our style guidelines.</p> </li> <li> <p>Check Test Coverage:    <pre><code>make coverage\n</code></pre>    Aim to maintain or improve the project's test coverage with your changes.</p> </li> <li> <p>Performance Benchmarking:    If your changes might impact performance, run our benchmarks:    <pre><code>make benchmark\n</code></pre>    Include these results in your pull request description if relevant.</p> </li> </ol>"},{"location":"contributing/#committing-your-changes","title":"Committing Your Changes","text":"<ol> <li>Follow Conventional Commits:    We use Conventional Commits for clear and standardized commit messages. For example:</li> </ol> <pre><code>feat: add new ranking algorithm for improved accuracy\nfix: resolve issue with parsing certain file formats\ndocs: update installation instructions in README\n</code></pre> <ol> <li>Push Your Changes:    Push your branch to your fork on GitHub:    <pre><code>git push origin feature/your-feature-name\n</code></pre></li> </ol>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Go to the RTN GitHub repository.</li> <li>Click \"Pull requests\" and then \"New pull request\".</li> <li>Choose your fork and the branch containing your changes.</li> <li>Click \"Create pull request\".</li> <li>Provide a clear title and detailed description of your changes, including:</li> <li>The problem you're solving</li> <li>Your approach to the solution</li> <li>Any potential impacts or considerations</li> <li>Benchmark results, if applicable</li> </ol>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you need assistance or have questions:</p> <ul> <li>Open an issue for bugs or feature discussions</li> <li>Join our Discord community for real-time chat</li> <li>Check out the FAQ for common questions</li> </ul> <p>Thank you for contributing to RTN! Your efforts help make this project better for everyone. We look forward to your contributions and are here to support you throughout the process.</p>"},{"location":"license/","title":"License","text":""},{"location":"license/#mit-license","title":"MIT License","text":"<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <ol> <li> <p>Inclusion of Copyright Notice: The above copyright notice and this permission     notice shall be included in all copies or substantial portions of the Software.</p> </li> <li> <p>Disclaimer of Warranty: The Software is provided \"AS IS\", without warranty     of any kind, express or implied, including but not limited to the warranties     of merchantability, fitness for a particular purpose and noninfringement.     In no event shall the authors or copyright holders be liable for any claim,     damages or other liability, whether in an action of contract, tort or otherwise,     arising from, out of or in connection with the Software or the use or other     dealings in the Software.</p> </li> <li> <p>Limitation of Liability: The authors and copyright holders of this software     shall not be held liable for any damages, losses, or consequences arising from     the use, misuse, or inability to use the Software. Users of this software assume     all risks associated with its use and agree to indemnify and hold harmless the     authors and copyright holders from any claims, damages, or liabilities arising     from the use of the Software.</p> </li> </ol> <p>By using this Software, you acknowledge that you have read and understood these  terms and agree to be bound by them.</p>"},{"location":"devs/extras/","title":"Extras","text":""},{"location":"devs/extras/#get_lev_ratio","title":"get_lev_ratio","text":"<p>source <pre><code>.get_lev_ratio(\n   correct_title: str, parsed_title: str, threshold: float = 0.85\n)\n</code></pre></p> <p>Compares two titles using the Levenshtein ratio to determine similarity.</p> <p>Args</p> <ul> <li>The reference title to compare against.</li> <li>The title to compare with the reference title.</li> <li>The similarity threshold to consider the titles as matching.</li> <li>A dictionary of aliases for the correct title. (default: {}, optional)</li> </ul> <p>Returns</p> <ul> <li>The Levenshtein ratio between the two titles.</li> </ul>"},{"location":"devs/extras/#title_match","title":"title_match","text":"<p>source <pre><code>.title_match(\n   correct_title: str, parsed_title: str, threshold: float = 0.85\n)\n</code></pre></p> <p>Compares two titles using the Levenshtein ratio to determine similarity.</p> <p>Args</p> <ul> <li>The reference title to compare against.</li> <li>The title to compare with the reference title.</li> <li>The similarity threshold to consider the titles as matching.</li> </ul> <p>Returns</p> <ul> <li>True if the titles match, False otherwise.</li> </ul>"},{"location":"devs/extras/#sort_torrents","title":"sort_torrents","text":"<p>source <pre><code>.sort_torrents(\n   torrents: Set[Torrent]\n)\n</code></pre></p> <p>Sorts a set of Torrent objects by their resolution bucket and then by their rank in descending order. Returns a dictionary with infohash as keys and Torrent objects as values.</p> <p>Args</p> <ul> <li>A set of Torrent objects.</li> </ul> <p>Raises</p> <ul> <li>If the input is not a set of Torrent objects.</li> </ul> <p>Returns</p> <ul> <li>A dictionary of Torrent objects sorted by resolution and rank in descending order, with the torrent's infohash as the key.</li> </ul>"},{"location":"devs/extras/#extract_seasons","title":"extract_seasons","text":"<p>source <pre><code>.extract_seasons(\n   raw_title: str\n)\n</code></pre></p> <p>Extract season numbers from the title or filename.</p> <p>Args</p> <ul> <li>The original title of the torrent to analyze.</li> </ul> <p>Returns</p> <ul> <li>A list of extracted season numbers from the title.</li> </ul>"},{"location":"devs/extras/#extract_episodes","title":"extract_episodes","text":"<p>source <pre><code>.extract_episodes(\n   raw_title: str\n)\n</code></pre></p> <p>Extract episode numbers from the title or filename.</p> <p>Args</p> <ul> <li>The original title of the torrent to analyze.</li> </ul> <p>Returns</p> <ul> <li>A list of extracted episode numbers from the title.</li> </ul>"},{"location":"devs/extras/#episodes_from_season","title":"episodes_from_season","text":"<p>source <pre><code>.episodes_from_season(\n   raw_title: str, season_num: int\n)\n</code></pre></p> <p>Only return episode numbers if the season number is found in the title and the season number matches the input season number.</p> <p>Args</p> <ul> <li>The original title of the torrent to analyze.</li> <li>The season number to extract episodes for.</li> </ul> <p>Returns</p> <ul> <li>A list of extracted episode numbers for the specified season.</li> </ul>"},{"location":"devs/introduction/","title":"Why?","text":"<p>Here are the key points about how ranking works in Rank Torrent Name (RTN):</p> <ol> <li>RTN uses a customizable ranking system that allows users to define their preferences for filtering and ranking torrents.</li> <li>The ranking process involves parsing the torrent name and evaluating it based on defined criteria.</li> <li>Users can modify the <code>SettingsModel</code> to specify their preferences, including patterns to look for, attributes to exclude, and preferences for features like resolution and audio quality.</li> <li>The ranking system uses a <code>RankingModel</code> to compute scores based on user-defined preferences, allowing for a nuanced scoring system.</li> <li>The process includes parsing the torrent title, extracting metadata, and calculating a rank based on the settings and ranking model.</li> <li>RTN can sort multiple torrents based on their calculated ranks to help users choose the best option.</li> <li>The ranking takes into account various factors like resolution, audio quality, and other user-defined criteria.</li> <li>The system allows for dynamic adjustment of ranking criteria at runtime, giving users flexibility in how torrents are evaluated.</li> <li>RTN uses a Levenshtein ratio in tangent with normalization to ensure accuracy by comparing parsed titles with original titles.</li> </ol> <p>In summary, Rank Torrent Name provides a flexible and customizable system for ranking torrents based on user-defined criteria, allowing for detailed analysis and sorting of torrent metadata to find the best quality options.</p>"},{"location":"devs/introduction/#installation","title":"Installation","text":"<p>You can install <code>rank-torrent-name</code> using pip:</p> <pre><code>pip install rank-torrent-name\n</code></pre> <p>or you can add it to your project through <code>Poetry</code> as well,</p> <pre><code>poetry add rank-torrent-name\n</code></pre>"},{"location":"devs/introduction/#quick-start","title":"\ud83c\udf89 Quick Start","text":""},{"location":"devs/introduction/#ranking-torrents","title":"Ranking Torrents","text":"<ol> <li>Rank a Torrent: Feed a torrent title to RTN to parse it and calculate its rank based on your settings.</li> </ol> <pre><code>from RTN import RTN\nfrom RTN.models import DefaultRanking, SettingsModel\n\nsettings = SettingsModel() # you can modify the settings model to your liking.\nrtn = RTN(settings=settings, ranking_model=DefaultRanking())\ntorrent = rtn.rank(\"Example.Movie.2020.1080p.BluRay.x264-Example\", \"1231231231231231231231231231231231231231\")\n\nprint(torrent.data.parsed_title) # \"Example Movie\"\nprint(torrent.rank) # 600\nprint(torrent.fetch) # True\nprint(torrent.data.trash) # False\n</code></pre> <ol> <li>Inspecting the Torrent Object: The returned <code>Torrent</code> object includes parsed data and a rank. Access its properties to understand its quality:</li> </ol> <pre><code>print(f\"Title: {torrent.data.parsed_title}, Rank: {torrent.rank}\")\n</code></pre> <p>Warning</p> <p>To get a ratio you must provide the <code>correct_title</code> parameter in <code>.rank()</code>. This is what's used to calculate the ratio. This needs to be the metadata title, not the raw title. If you don't have the metadata title, you can provide the query from the user instead.</p>"},{"location":"devs/introduction/#torrent-object","title":"Torrent Object","text":"<p>A <code>Torrent</code> object encapsulates metadata about a torrent, such as its title, parsed information, and rank. Here's an example structure:</p> <pre><code>Torrent(\n    raw_title=\"Example.Movie.2020.1080p.BluRay.x264-Example\",\n    infohash=\"infohash123456\",\n    data=ParsedData(parsed_title='Example Movie', ...),\n    fetch=True,\n    rank=150,\n    lev_ratio=0.95\n)\n</code></pre>"},{"location":"devs/introduction/#understanding-settingsmodel-and-rankingmodel","title":"Understanding SettingsModel and RankingModel","text":"<p>SettingsModel and RankingModel play crucial roles in RTN, offering users flexibility in filtering and ranking torrents according to specific needs. Here's what each model offers and why they are important:</p>"},{"location":"devs/introduction/#settingsmodel","title":"SettingsModel","text":"<p><code>SettingsModel</code> is where you define your filtering criteria, including patterns to require, exclude, and prefer in torrent names. This model allows for dynamic configuration of torrent selection based on user-defined patterns and preferences. </p> <p>Key functionalities: - Filtering Torrents: Determine which torrents to consider or ignore based on matching patterns. - Prioritizing Torrents: Indicate preferred attributes that give certain torrents higher precedence. - Custom Ranks Usage: Decide how specific attributes influence the overall ranking, enabling or disabling custom ranks.</p> <p>Example usage: <pre><code>from RTN.models import SettingsModel, CustomRank\n\nsettings = SettingsModel(\n    require=[\"1080p\", \"4K\"],\n    exclude=[\"CAM\"],\n    preferred=[\"HDR\", \"/SenSiTivE/\"],\n    custom_ranks={\n        \"uhd\": CustomRank(enable=True, fetch=True, rank=200),\n        \"hdr\": CustomRank(enable=True, fetch=True, rank=100),\n    }\n)\n</code></pre></p> <p>As shown above with \"/SenSiTivE/\", you are able to set explicit case sensitivity as well for entering patterns for <code>require</code>, <code>exclude</code> and <code>preferred</code> attributes. We default to ignore case sensitivity.</p>"},{"location":"devs/introduction/#rankingmodel","title":"RankingModel","text":"<p>While <code>SettingsModel</code> focuses on the selection and preference of torrents, <code>RankingModel</code> (such as <code>BaseRankingModel</code> or its extensions) is designed to compute the ranking scores based on those preferences. This model allows for the creation of a nuanced scoring system that evaluates each torrent's quality and attributes, translating user preferences into a quantifiable score.</p> <p>Key functionalities: - Scoring Torrent Attributes: Assign scores to various torrent attributes like resolution, audio quality, etc. - Customizable Ranking Logic: Extend <code>BaseRankingModel</code> to tailor ranking criteria and values, enhancing the decision-making process in selecting torrents.</p> <p>Example usage: <pre><code>from RTN.models import BaseRankingModel\n\nclass MyRankingModel(BaseRankingModel):\n    uhd = 200  # Ultra HD content\n    hdr = 100  # HDR content\n    # Define more attributes and scores as needed\n</code></pre></p>"},{"location":"devs/introduction/#why-both-models-are-necessary","title":"Why Both Models are Necessary","text":"<p><code>SettingsModel</code> and <code>RankingModel</code> work together to provide a comprehensive approach to torrent ranking: - SettingsModel specifies what to look for in torrents, defining the search and preference criteria. - RankingModel quantifies those preferences, assigning scores to make informed decisions on which torrents are of higher quality and relevance.</p> <p>This separation allows for flexible configuration and a powerful, customizable ranking system tailored to individual user preferences.</p> <p>Create as many <code>SettingsModel</code> and <code>RankingModel</code> as you like to use anywhere in your code. They are mean't to be used as a way to version settings for your users. </p>"},{"location":"devs/introduction/#real-world-example","title":"Real World Example","text":"<p>Here is a crude example of how you could use RTN in scraping.</p> <pre><code>from RTN import RTN, Torrent, DefaultRanking\nfrom RTN.exceptions import GarbageTorrent\n\n# Assuming 'settings' is defined somewhere and passed correctly.\nrtn = RTN(settings=settings, ranking_model=DefaultRanking())\n...\n# Define some function for scraping for results from some API.\n    if response.ok:\n        torrents = set()\n        for stream in response.streams:\n            try:\n                torrent: Torrent = rtn.rank(\n                    stream.title,\n                    infohash=stream.infohash\n                    correct_title=correct_title_or_query,\n                    remove_trash=True\n                )\n            except GarbageTorrent:\n                # One thing to note is that as we parse titles, we also get rid of garbage.\n                # Feel free to add your own logic when this happens!\n                # You can bypass this by setting `remove_trash` to `False` in the `rank` method.\n                continue\n            if torrent and torrent.fetch:\n                # If torrent.fetch is True, then it's a good torrent,\n                # as considered by your ranking profile and settings model.\n                torrents.add(torrent)\n\n        # Sort the list of torrents based on their rank in descending order, and resolution buckets intact.\n        return sort_torrents(torrents)\n    ...\n\n# Example usage\nfor torrent in sorted_torrents:\n    print(f\"Title: {torrent.data.parsed_title}, Infohash: {torrent.infohash}, Rank: {torrent.rank}\")\n</code></pre>"},{"location":"devs/introduction/#parseddata-structure","title":"ParsedData Structure","text":"<p>Here is all of the attributes of <code>data</code> from the <code>Torrent</code> object, along with their default values.</p> <p>This is accessible at <code>torrent.data</code> in the <code>Torrent</code> object.  Example: </p> <pre><code>print(torrent.data.resolution) # '1080p'\n</code></pre> <p>Missing something?</p> <p>Don't see something you want in the list? Submit a Feature Request to have it added!</p>"},{"location":"devs/introduction/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Here, we dive into the heart of RTN's efficiency, showcasing how it performs under various loads. Whether you're parsing a single title or ranking thousands, understanding these benchmarks will help you optimize your use of RTN.</p>"},{"location":"devs/introduction/#benchmark-categories","title":"Benchmark Categories","text":"<p>We categorize benchmarks into two main processes:</p> <ul> <li>Parsing: Measures the time to parse a title and return a <code>ParsedData</code> object. This process focuses solely on extracting information from the torrent title.</li> <li>Ranking: A comprehensive process that includes parsing and then evaluates the title based on defined criteria. It outputs a <code>Torrent</code> model, which includes a <code>data</code> attribute containing the <code>ParsedData</code> and additional ranking information. This represents a more \"real-world\" scenario and is crucial for developers looking to integrate RTN effectively.</li> </ul>"},{"location":"devs/introduction/#benchmark-results","title":"Benchmark Results","text":"<p>To facilitate comparison, we've compiled the results into a single table:</p> <p>Benchmarks Comparisons</p> Operation Items Count Mean Time Standard Deviation Parsing Benchmark (Single item) 1 779 us 36 us Batch Parse Benchmark (Small batch) 10 7.67 ms 0.38 ms Batch Parse Benchmark (Large batch) 1000 776 ms 24 ms Batch Parse Benchmark (XLarge batch) 2000 1.55 s 0.04 s Ranking Benchmark (Single item) 1 796 us 15 us Batch Rank Benchmark (Small batch) 10 7.98 ms 0.19 ms Batch Rank Benchmark (Large batch) 1000 806 ms 11 ms Batch Rank Benchmark (XLarge batch) 2000 1.65 s 0.05 s <p>Test Bench Specs</p> <p>Test Bench consisted of R9 5900X CPU and 64GB DDR4 RAM - Your mileage may vary.</p> <p>This data shows RTN's robust capability to efficiently process both small and extensive datasets.</p> <ul> <li>To run your own benchmark, you can clone the repo and run <code>make benchmark</code> from inside the root of the repository.</li> </ul>"},{"location":"devs/models/","title":"Models","text":""},{"location":"devs/models/#parseddata","title":"ParsedData","text":"<p>source <pre><code>ParsedData()\n</code></pre> Parsed data model for a torrent title.</p> <p>Methods:</p>"},{"location":"devs/models/#type","title":".type","text":"<p>source <pre><code>.type()\n</code></pre> Returns the type of the torrent based on its attributes.</p>"},{"location":"devs/models/#to_dict","title":".to_dict","text":"<p>source <pre><code>.to_dict()\n</code></pre> Returns a json serializable dictionary of the parsed data.</p>"},{"location":"devs/models/#torrent","title":"Torrent","text":"<p>source <pre><code>Torrent()\n</code></pre> Represents a torrent with metadata parsed from its title and additional computed properties.</p> <p>Attributes</p> <ul> <li>The original title of the torrent.</li> <li>The SHA-1 hash identifier of the torrent.</li> <li>Metadata extracted from the torrent title.</li> <li>Indicates whether the torrent meets the criteria for fetching based on user settings.</li> <li>The computed ranking score of the torrent based on user-defined preferences.</li> <li>The Levenshtein ratio comparing the parsed title and the raw title for similarity.</li> </ul> <p>Methods:     hash: Generates a hash based on the infohash of the torrent for set operations.</p> <p>Raises</p> <ul> <li>If the title is identified as trash and should be ignored by the scraper.</li> </ul> <p>Example</p> <pre><code>&gt;&gt;&gt; isinstance(torrent, Torrent)\nTrue\n&gt;&gt;&gt; torrent.raw_title\n'The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]'\n&gt;&gt;&gt; torrent.infohash\n'c08a9ee8ce3a5c2c08865e2b05406273cabc97e7'\n&gt;&gt;&gt; torrent.data.parsed_title\n'The Walking Dead'\n&gt;&gt;&gt; torrent.fetch\nTrue\n&gt;&gt;&gt; torrent.rank\n500\n&gt;&gt;&gt; torrent.lev_ratio\n0.95\n</code></pre> <p>Methods:</p>"},{"location":"devs/models/#to_dict_1","title":".to_dict","text":"<p>source <pre><code>.to_dict()\n</code></pre></p>"},{"location":"devs/models/#baserankingmodel","title":"BaseRankingModel","text":"<p>source <pre><code>BaseRankingModel()\n</code></pre></p> <p>A base class for ranking models used in the context of media quality and attributes. The ranking values are used to determine the quality of a media item based on its attributes.</p> <p>Note</p> <ul> <li>The higher the ranking value, the better the quality of the media item.</li> <li>The default ranking values are set to 0, which means that the attribute does not affect the overall rank.</li> <li>Users can customize the ranking values based on their preferences and requirements by using inheritance.</li> </ul>"},{"location":"devs/models/#defaultranking","title":"DefaultRanking","text":"<p>source <pre><code>DefaultRanking()\n</code></pre> Ranking model preset that covers the highest qualities like 4K HDR.</p>"},{"location":"devs/models/#settingsmodel","title":"SettingsModel","text":"<p>source <pre><code>SettingsModel()\n</code></pre></p> <p>Represents user-defined settings for ranking torrents, including preferences for filtering torrents based on regex patterns and customizing ranks for specific torrent attributes. This model allows for advanced customization and fine-grained control over the ranking process.</p> <p>Attributes</p> <ul> <li>require (List[str | Pattern]) : Patterns torrents must match to be considered.</li> <li>exclude (List[str | Pattern]) : Patterns that, if matched, result in torrent exclusion.</li> <li>preferred (List[str | Pattern]) : Patterns indicating preferred attributes in torrents. Given +5000 points by default.</li> <li>custom_ranks (Dict[str, Dict[str, CustomRank]]) : Custom ranking configurations for specific attributes, allowing users to define how different torrent qualities and features affect the overall rank.</li> </ul> <p>Methods:     getitem(item: str) -&gt; CustomRank: Access custom rank settings via attribute keys.</p> <p>Note</p> <ul> <li>The <code>require</code>, <code>exclude</code>, and <code>preferred</code> attributes are optional!</li> <li>The <code>custom_ranks</code> attribute contains default values for common torrent attributes, which can be customized by users.</li> <li>Patterns enclosed in '/' without a trailing 'i' are compiled as case-sensitive.</li> <li>Patterns not enclosed are compiled as case-insensitive by default.</li> </ul> <p>This model supports advanced regex features, enabling powerful and precise filtering and ranking based on torrent titles and attributes.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; print([pattern.pattern for pattern in settings.require])\n['\\b4K|1080p\\b', '720p']\n&gt;&gt;&gt; print([pattern.pattern for pattern in settings.preferred])\n['BluRay', '\\bS\\d+', 'HDR|HDR10']\n&gt;&gt;&gt; print(settings.custom_ranks[\"uhd\"].rank)\n150\n</code></pre>"},{"location":"devs/models/#customrank","title":"CustomRank","text":"<p>source <pre><code>CustomRank()\n</code></pre></p> <p>Custom Ranks used in SettingsModel.</p>"},{"location":"devs/parsing/","title":"Parsing","text":""},{"location":"devs/parsing/#parsing-overview","title":"Parsing Overview","text":"<p>The RTN package offers comprehensive and powerful functionality for parsing torrent titles and extracting detailed metadata. This functionality is primarily implemented through two key components: the <code>parse</code> function in <code>parser.py</code> and the <code>ParsedData</code> model in <code>models.py</code>. In this section, we will provide an in-depth look at these components and their roles in the parsing process.</p>"},{"location":"devs/parsing/#parserpy","title":"parser.py","text":"<p>The <code>parser.py</code> module is the core of the parsing functionality. It is responsible for analyzing torrent titles and enriching them with additional metadata. This module includes the crucial <code>parse</code> function that works to achieve this goal.</p>"},{"location":"devs/parsing/#parseddata-model","title":"ParsedData Model","text":"<p>The <code>ParsedData</code> model is a comprehensive data structure that represents the parsed metadata of a torrent title. It uses Pydantic's <code>BaseModel</code> for data validation and serialization.</p>"},{"location":"devs/parsing/#attributes","title":"Attributes","text":"Attribute Description <code>raw_title</code> The original, unprocessed torrent title. <code>parsed_title</code> The cleaned and standardized version of the title. <code>normalized_title</code> A further normalized version of the title for easier matching and comparison. <code>trash</code> Indicates if the torrent is considered trash. <code>year</code> The release year of the content (if available). <code>resolution</code> The video resolution (e.g., \"1080p\", \"4K\"). <code>seasons</code> List of season numbers for TV shows. <code>episodes</code> List of episode numbers for TV shows. <code>complete</code> Indicates if the torrent contains a complete season or series. <code>volumes</code> List of volume numbers. <code>languages</code> List of languages available in the torrent. <code>quality</code> The overall quality descriptor (e.g., \"HDTV\", \"WEBRip\"). <code>hdr</code> List of HDR formats. <code>codec</code> The video codec used (e.g., \"HEVC\"). <code>audio</code> List of audio codecs or formats. <code>channels</code> List of audio channels. <code>dubbed</code> Indicates if the torrent is dubbed. <code>subbed</code> Indicates if the torrent has subtitles. <code>date</code> The release date of the torrent. <code>group</code> The release group responsible for the torrent. <code>edition</code> The edition of the torrent. <code>bit_depth</code> The bit depth of the video. <code>bitrate</code> The bitrate of the video. <code>network</code> The network that aired the content. <code>extended</code> Indicates if the torrent is an extended version. <code>converted</code> Indicates if the torrent has been converted from another format. <code>hardcoded</code> Indicates if the torrent has hardcoded subtitles. <code>region</code> The region code of the torrent. <code>ppv</code> Indicates if the torrent is a pay-per-view content. <code>_3d</code> Indicates if the torrent is in 3D. <code>site</code> The site from which the torrent was sourced. <code>size</code> The size of the torrent. <code>proper</code> Indicates if the torrent is a proper release. <code>repack</code> Indicates if the torrent is a repack. <code>retail</code> Indicates if the torrent is a retail version. <code>upscaled</code> Indicates if the torrent has been upscaled. <code>remastered</code> Indicates if the torrent has been remastered. <code>unrated</code> Indicates if the torrent is an unrated version. <code>documentary</code> Indicates if the torrent is a documentary. <code>episode_code</code> The episode code of the torrent. <code>country</code> The country of origin of the content. <code>container</code> The container format of the torrent. <code>extension</code> The file extension of the torrent. <code>torrent</code> Indicates if the data represents a torrent."},{"location":"devs/parsing/#usage-examples","title":"Usage Examples","text":"<ol> <li>Creating a ParsedData instance:</li> </ol> <pre><code>from RTN.models import ParsedData\n\nparsed_data = parse(\"Game.of.Thrones.S01E01.1080p.WEBRip.DD5.1.x264-GalaxyRG[TGx]\")\nprint(result)\n</code></pre> <p>Result: <pre><code>ParsedData(\n    raw_title='Game.of.Thrones.S01E01.1080p.WEBRip.DD5.1.x264-GalaxyRG[TGx]',\n    parsed_title='Game of Thrones',\n    normalized_title='game of thrones',\n    trash=False,\n    resolution='1080p',\n    seasons=[1],\n    episodes=[1],\n    quality='WEBRip',\n    codec='avc',\n    audio=['Dolby Digital'],\n    channels=['5.1'],\n    group='GalaxyRG',\n)\n</code></pre></p> <ol> <li>Accessing attributes:</li> </ol> <pre><code>print(parsed_data.resolution)  # Output: \"1080p\"\nprint(parsed_data.type)  # Output: \"show\"\n</code></pre> <ol> <li>Converting to json:</li> </ol> <pre><code>data_dict = parsed_data.to_dict()\nprint(data_dict)\n# Output: JSON string representation of the ParsedData instance\n</code></pre>"},{"location":"devs/parsing/#benefits-for-developers","title":"Benefits for Developers","text":"<ul> <li>Standardization: The <code>ParsedData</code> model ensures consistent representation of parsed torrent metadata across the application.</li> <li>Type Safety: Pydantic's type checking helps catch errors early in development.</li> <li>Easy Serialization: The <code>to_dict()</code> method allows for simple conversion to JSON for API responses or database storage.</li> <li>Extensibility: New attributes can be easily added to accommodate future parsing requirements.</li> </ul> <p>By using the <code>ParsedData</code> model, developers can work with structured, validated torrent metadata, making it easier to implement features like searching, filtering, and ranking of torrents based on their attributes.</p>"},{"location":"devs/ranking/","title":"Ranking","text":""},{"location":"devs/ranking/#rtn","title":"RTN","text":"<p>source <pre><code>from RTN import RTN\nrtn = RTN(settings: SettingsModel, ranking_model: BaseRankingModel)\n</code></pre></p> <p>RTN (Rank Torrent Name) class for parsing and ranking torrent titles based on user preferences.</p> <p>Args</p> <ul> <li>The settings model with user preferences for parsing and ranking torrents.</li> <li>The model defining the ranking logic and score computation.</li> </ul> <p>Notes</p> <ul> <li>Both <code>settings</code> and <code>ranking_model</code> must be provided and must be valid instances of <code>SettingsModel</code> and <code>BaseRankingModel</code>.</li> <li>The <code>lev_threshold</code> is derived from <code>settings.options[\"title_similarity\"]</code> and is used to determine if a torrent title matches the correct title.</li> </ul> <p>Methods:</p>"},{"location":"devs/ranking/#rank","title":".rank","text":"<p>source <pre><code>.rank(\n   raw_title: str, infohash: str, correct_title: str = '', remove_trash: bool = False\n)\n</code></pre></p> <p>Parses a torrent title, computes its rank, and returns a Torrent object with metadata and ranking.</p> <p>Args</p> <ul> <li>The original title of the torrent to parse.</li> <li>The SHA-1 hash identifier of the torrent.</li> <li>The correct title to compare against for similarity. Defaults to an empty string.</li> <li>Whether to check for trash patterns and raise an error if found. Defaults to True.</li> </ul> <p>Returns</p> <ul> <li>Torrent  : A Torrent object with metadata and ranking information.</li> </ul> <p>Raises</p> <ul> <li>ValueError  : If the title or infohash is not provided for any torrent.</li> <li>TypeError  : If the title or infohash is not a string.</li> <li>GarbageTorrent  : If the title is identified as trash and should be ignored by the scraper, or invalid SHA-1 infohash is given.</li> </ul> <p>Notes:     - If <code>correct_title</code> is provided, the Levenshtein ratio will be calculated between the parsed title and the correct title.     - If the ratio is below the threshold, a <code>GarbageTorrent</code> error will be raised.     - If no correct title is provided, the Levenshtein ratio will be set to 0.0.</p> <p>Example</p> <pre><code>from RTN import RTN\nfrom RTN.models import SettingsModel, DefaultRanking\n\nsettings_model = SettingsModel()\nranking_model = DefaultRanking()\nrtn = RTN(settings_model, ranking_model)\ntorrent = rtn.rank(\"The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]\", \"c08a9ee8ce3a5c2c08865e2b05406273cabc97e7\")\nassert isinstance(torrent, Torrent)\nassert isinstance(torrent.data, ParsedData)\nassert torrent.fetch\nassert torrent.rank &gt; 0\nassert torrent.lev_ratio &gt; 0.0\n</code></pre>"},{"location":"devs/ranking/#get_rank","title":"get_rank","text":"<p>source <pre><code>.get_rank(\n   data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel\n)\n</code></pre></p> <p>Calculate the ranking of the given parsed data.</p> <p>Parameters: <code>data</code> (ParsedData): The parsed data object containing information about the torrent title. <code>settings</code> (SettingsModel): The user settings object containing custom ranking models. <code>rank_model</code> (BaseRankingModel): The base ranking model used for calculating the ranking.</p> <p>Returns</p> <ul> <li>int  : The calculated ranking value for the parsed data.</li> </ul> <p>Raises</p> <ul> <li>ValueError  : If the parsed data is empty.</li> <li>TypeError  : If the parsed data is not a ParsedData object.</li> </ul>"},{"location":"devs/ranking/#calculate_preferred","title":"calculate_preferred","text":"<p>source <pre><code>.calculate_preferred(\n   data: ParsedData, settings: SettingsModel\n)\n</code></pre></p> <p>Calculate the preferred ranking of a given parsed data.</p>"},{"location":"devs/ranking/#calculate_quality_rank","title":"calculate_quality_rank","text":"<p>source <pre><code>.calculate_quality_rank(\n   data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel\n)\n</code></pre></p> <p>Calculate the quality ranking of the given parsed data.</p>"},{"location":"devs/ranking/#calculate_codec_rank","title":"calculate_codec_rank","text":"<p>source <pre><code>.calculate_codec_rank(\n   data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel\n)\n</code></pre></p> <p>Calculate the codec ranking of the given parsed data.</p>"},{"location":"devs/ranking/#calculate_audio_rank","title":"calculate_audio_rank","text":"<p>source <pre><code>.calculate_audio_rank(\n   data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel\n)\n</code></pre></p> <p>Calculate the audio ranking of the given parsed data.</p>"},{"location":"devs/ranking/#calculate_extra_ranks","title":"calculate_extra_ranks","text":"<p>source <pre><code>.calculate_extra_ranks(\n   data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel\n)\n</code></pre></p> <p>Calculate all the other rankings of the given parsed data.</p>"},{"location":"devs/settings/","title":"Settings Model","text":""},{"location":"devs/settings/#settingsmodel","title":"SettingsModel","text":"<p>source <pre><code>from RTN.models import SettingsModel\nsettings = SettingsModel()\n</code></pre></p> <p>Represents user-defined settings for ranking torrents, including preferences for filtering torrents based on regex patterns and customizing ranks for specific torrent attributes. This model allows for advanced customization and fine-grained control over the ranking process.</p> <p>Attributes</p> <ul> <li>require (List[str | Pattern]) : Patterns torrents must match to be considered.</li> <li>exclude (List[str | Pattern]) : Patterns that, if matched, result in torrent exclusion.</li> <li>preferred (List[str | Pattern]) : Patterns indicating preferred attributes in torrents. Given +5000 points by default.</li> <li>custom_ranks (Dict[str, Dict[str, CustomRank]]) : Custom ranking configurations for specific attributes, allowing users to define how different torrent qualities and features affect the overall rank.</li> </ul> <p>Methods:</p> <pre><code>__getitem__(item: str) -&gt; CustomRank: Access custom rank settings via attribute keys.\n</code></pre> <p>Note</p> <ul> <li>The <code>require</code>, <code>exclude</code>, and <code>preferred</code> attributes are optional!</li> <li>The <code>custom_ranks</code> attribute contains default values for common torrent attributes, which can be customized by users.</li> <li>Patterns enclosed in '/' without a trailing 'i' are compiled as case-sensitive.</li> <li>Patterns not enclosed are compiled as case-insensitive by default.</li> </ul> <p>This model supports advanced regex features, enabling powerful and precise filtering and ranking based on torrent titles and attributes.</p>"},{"location":"devs/settings/#customrank","title":"CustomRank","text":"<p>source <pre><code>CustomRank()\n</code></pre></p> <p>Custom Ranks used in SettingsModel.</p>"},{"location":"devs/settings/#settingsmodel_1","title":"SettingsModel","text":"<p><code>SettingsModel</code> is designed to be fully customizable by users, allowing you to define your own filtering criteria, including patterns to require, exclude, and prefer in torrent names. This model empowers you to dynamically configure torrent selection based on your specific patterns and preferences.</p> <p>Key functionalities:</p> <ul> <li>Filtering Torrents: You have the control to determine which torrents to consider or ignore based on your matching patterns.</li> <li>Prioritizing Torrents: Indicate your preferred attributes to give certain torrents higher precedence according to your needs.</li> <li>Custom Ranks Usage: Decide how specific attributes influence the overall ranking, enabling or disabling custom ranks as you see fit.</li> </ul> <p>Warning</p> <p>The <code>SettingsModel</code> is only used when ranking torrents, you do not need it if you are just wanting to <code>parse()</code> torrents.</p>"},{"location":"devs/settings/#setup-your-settings-model","title":"Setup your Settings Model","text":"<p>Begin by defining your preferences in a <code>SettingsModel</code>. This includes specifying the required patterns, exclusions, preferences, and custom ranks for various torrent attributes. The <code>SettingsModel</code> allows you to customize how torrents are filtered and ranked based on your specific needs.</p> <ul> <li>require: These are patterns that must be present in the torrent name for it to be considered.</li> <li>exclude: These are patterns that, if present in the torrent name, will exclude the torrent from consideration.</li> <li>preferred: These are patterns that, if present, will give the torrent a higher priority.</li> <li>resolutions: These will be used to determine what is fetched when ranking torrents.</li> <li>options: These are options that can be used to customize the behavior of the RTN.</li> <li>languages: These are languages that can be used to customize the behavior of the RTN.</li> <li>custom_ranks: These allow you to assign specific ranks to various attributes of the torrents, such as quality or resolution.</li> </ul> <p>Here is what the default settings model looks like, including the default values for each attribute:</p>"},{"location":"devs/settings/#example-usage","title":"Example Usage","text":"<pre><code>from typing import List, Dict\nfrom RTN.models import SettingsModel, CustomRank\n\nsettings = SettingsModel(\n    require: List[str | Pattern] = []\n    exclude: List[str | Pattern] = []\n    preferred: List[str | Pattern] = []\n    resolutions: Dict[str, bool] = {\n        \"2160p\": False,\n        \"1080p\": True,\n        \"720p\": True,\n        \"480p\": False,\n        \"360p\": False,\n        \"unknown\": True\n    }\n    options: Dict[str, Any] = {\n        \"title_similarity\": 0.85,\n        \"remove_all_trash\": True,\n        \"remove_ranks_under\": -10000,\n        \"remove_unknown_languages\": False,\n        \"allow_english_in_languages\": False\n    }\n    languages: Dict[str, Any] = {\n        \"required\": [],\n        \"exclude\": [\"common\"],\n        \"preferred\": [],\n    }\n    custom_ranks: Dict[str, Dict[str, CustomRank]] = {\n        \"quality\": {\n            \"av1\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"avc\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"bluray\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"dvd\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"hdtv\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"hevc\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"mpeg\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"remux\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"vhs\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"web\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"webdl\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"webmux\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"xvid\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n        },\n        \"rips\": {\n            \"bdrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"brrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"dvdrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"hdrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"ppvrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"satrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"tvrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"uhdrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"vhsrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"webdlrip\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"webrip\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n        },\n        \"hdr\": {\n            \"10bit\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"dolby_vision\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"hdr\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"hdr10plus\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"sdr\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n        },\n        \"audio\": {\n            \"aac\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"ac3\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"atmos\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"dolby_digital\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"dolby_digital_plus\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"dts_lossy\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"dts_lossless\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"eac3\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"flac\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"mono\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"mp3\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"stereo\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"surround\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"truehd\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n        },\n        \"extras\": {\n            \"3d\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"converted\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"documentary\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"dubbed\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"edition\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"hardcoded\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"network\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"proper\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"repack\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"retail\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"site\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"subbed\": CustomRank(fetch=True, use_custom_rank=False, rank=0),\n            \"upscaled\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n        },\n        \"trash\": {\n            \"cam\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"clean_audio\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"pdtv\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"r5\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"screener\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"size\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"telecine\": CustomRank(fetch=False, use_custom_rank=False, rank=0),\n            \"telesync\": CustomRank(fetch=False, use_custom_rank=False, rank=0)\n        },\n    }\n)\n</code></pre> <p>We cover a lot already, so users are able to add their own custom regex patterns without worrying about the basic patterns.</p>"},{"location":"devs/settings/#understanding-fetch-and-custom-rank","title":"Understanding Fetch and Custom Rank","text":"<ul> <li><code>fetch</code>: Determines if RTN should consider a torrent for downloading based on the attribute. True means RTN will fetch torrents matching this criterion.</li> <li><code>use_custom_rank</code>: Controls whether the custom rank value is used in the overall ranking calculation. Disabling it reverts to using the ranking model you set instead. This is useful for toggling custom ranks on and off from a users perspective.</li> <li><code>rank</code>: Sets the rank at which that item is graded with.</li> </ul>"},{"location":"devs/sorting/","title":"Sorting Torrents with <code>sort_torrents</code>","text":""},{"location":"devs/sorting/#overview","title":"Overview","text":"<p>The <code>sort_torrents</code> function sorts a set of <code>Torrent</code> objects by their resolution and then by rank, returning a dictionary where each torrent's <code>infohash</code> serves as the key. Torrents are first categorized into resolution buckets, with higher resolutions receiving higher priority. Within each resolution group, torrents are sorted by rank in descending order. If a torrent lacks a rank, it is treated as having an unknown rank, and is placed at the bottom of the list. The function ensures that only valid sets of <code>Torrent</code> objects are processed, raising a <code>TypeError</code> otherwise. This sorting helps prioritize higher-quality torrents for easier selection.</p>"},{"location":"devs/sorting/#sort_torrents","title":"sort_torrents","text":"<p>source <pre><code>.sort_torrents(\n   torrents: Set[Torrent]\n)\n</code></pre></p> <p>Sorts a set of Torrent objects by their resolution bucket and then by their rank in descending order. Returns a dictionary with infohash as keys and Torrent objects as values.</p> <p>Args</p> <ul> <li>A set of Torrent objects.</li> </ul> <p>Raises</p> <ul> <li>If the input is not a set of Torrent objects.</li> </ul> <p>Returns</p> <ul> <li>A dictionary of Torrent objects sorted by resolution and rank in descending order, with the torrent's infohash as the key.</li> </ul>"},{"location":"devs/sorting/#example-usage","title":"Example Usage","text":"<pre><code>from RTN.extras import sort_torrents\n\nsorted_torrents: Dict[str, Torrent] = sort_torrents(torrents)\n</code></pre>"},{"location":"devs/modules/exceptions/","title":"Exceptions","text":"<p>Custom exceptions for RTN.</p> <p>Exceptions: - <code>GarbageTorrent</code>: Raised when a torrent is considered garbage or invalid and should be ignored.</p> <p>Refer to the respective docstrings for more information.</p>"},{"location":"devs/modules/exceptions/#RTN.exceptions.GarbageTorrent","title":"<code>GarbageTorrent</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a torrent is considered garbage or invalid and should be ignored.</p> Source code in <code>RTN/exceptions.py</code> <pre><code>class GarbageTorrent(Exception):\n    \"\"\"Raised when a torrent is considered garbage or invalid and should be ignored.\"\"\"\n</code></pre>"},{"location":"devs/modules/exceptions/#RTN.exceptions.SettingsDisabled","title":"<code>SettingsDisabled</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the settings are disabled and cannot be used.</p> Source code in <code>RTN/exceptions.py</code> <pre><code>class SettingsDisabled(Exception):\n    \"\"\"Raised when the settings are disabled and cannot be used.\"\"\"\n</code></pre>"},{"location":"devs/modules/extras/","title":"Extras","text":"<p>Extras module for additional functionality related to RTN processing.</p> <p>Functions:</p> Name Description <code>- `title_match`</code> <p>Compare two titles using the Levenshtein ratio to determine similarity.</p> <code>- `sort_torrents`</code> <p>Sort a set of Torrent objects by their resolution and rank in descending order.</p> <code>- `extract_seasons`</code> <p>Extract season numbers from the title.</p> <code>- `extract_episodes`</code> <p>Extract episode numbers from the title.</p> <code>- `episodes_from_season`</code> <p>Extract episode numbers for a specific season from the title.</p> <p>For more details, please refer to the documentation.</p>"},{"location":"devs/modules/extras/#RTN.extras.episodes_from_season","title":"<code>episodes_from_season(raw_title, season_num)</code>","text":"<p>Only return episode numbers if the season number is found in the title and the season number matches the input season number.</p> <p>Parameters:</p> Name Type Description Default <code>`raw_title`</code> <code>str</code> <p>The original title of the torrent to analyze.</p> required <code>`season_num`</code> <code>int</code> <p>The season number to extract episodes for.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p><code>List[int]</code>: A list of extracted episode numbers for the specified season.</p> Source code in <code>RTN/extras.py</code> <pre><code>def episodes_from_season(raw_title: str, season_num: int) -&gt; List[int]:\n    \"\"\"\n    Only return episode numbers if the season number is found in the title\n    and the season number matches the input season number.\n\n    Args:\n        `raw_title` (str): The original title of the torrent to analyze.\n        `season_num` (int): The season number to extract episodes for.\n\n    Returns:\n        `List[int]`: A list of extracted episode numbers for the specified season.\n    \"\"\"\n    if not season_num:\n        raise ValueError(\"The season number must be provided.\")\n    if not isinstance(season_num, int) or season_num &lt;= 0:\n        raise TypeError(\"The season number must be a positive integer.\")\n    if not raw_title or not isinstance(raw_title, str):\n        raise ValueError(\"The input title must be a non-empty string.\")\n\n    data: dict[str, Any] = parse_title(raw_title)\n\n    season_from_title = data.get(\"seasons\", [])\n    episodes_from_title = data.get(\"episodes\", [])\n\n    if isinstance(episodes_from_title, list) and season_num in season_from_title:\n        return episodes_from_title\n    return []\n</code></pre>"},{"location":"devs/modules/extras/#RTN.extras.extract_episodes","title":"<code>extract_episodes(raw_title)</code>","text":"<p>Extract episode numbers from the title or filename.</p> <p>Parameters:</p> Name Type Description Default <code>`raw_title`</code> <code>str</code> <p>The original title of the torrent to analyze.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p><code>List[int]</code>: A list of extracted episode numbers from the title.</p> Source code in <code>RTN/extras.py</code> <pre><code>def extract_episodes(raw_title: str) -&gt; List[int]:\n    \"\"\"\n    Extract episode numbers from the title or filename.\n\n    Args:\n        `raw_title` (str): The original title of the torrent to analyze.\n\n    Returns:\n        `List[int]`: A list of extracted episode numbers from the title.\n    \"\"\"\n    if not raw_title or not isinstance(raw_title, str):\n        raise TypeError(\"The input title must be a non-empty string.\")\n    return parse_title(raw_title)[\"episodes\"]\n</code></pre>"},{"location":"devs/modules/extras/#RTN.extras.extract_seasons","title":"<code>extract_seasons(raw_title)</code>","text":"<p>Extract season numbers from the title or filename.</p> <p>Parameters:</p> Name Type Description Default <code>`raw_title`</code> <code>str</code> <p>The original title of the torrent to analyze.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p><code>List[int]</code>: A list of extracted season numbers from the title.</p> Source code in <code>RTN/extras.py</code> <pre><code>def extract_seasons(raw_title: str) -&gt; List[int]:\n    \"\"\"\n    Extract season numbers from the title or filename.\n\n    Args:\n        `raw_title` (str): The original title of the torrent to analyze.\n\n    Returns:\n        `List[int]`: A list of extracted season numbers from the title.\n    \"\"\"\n    if not raw_title or not isinstance(raw_title, str):\n        raise TypeError(\"The input title must be a non-empty string.\")\n    return parse_title(raw_title)[\"seasons\"]\n</code></pre>"},{"location":"devs/modules/extras/#RTN.extras.get_lev_ratio","title":"<code>get_lev_ratio(correct_title, parsed_title, threshold=0.85, aliases={})</code>","text":"<p>Compares two titles using the Levenshtein ratio to determine similarity.</p> <p>Parameters:</p> Name Type Description Default <code>`correct_title`</code> <code>str</code> <p>The reference title to compare against.</p> required <code>`parsed_title`</code> <code>str</code> <p>The title to compare with the reference title.</p> required <code>`threshold`</code> <code>float</code> <p>The similarity threshold to consider the titles as matching.</p> required <code>`aliases`</code> <code>dict</code> <p>A dictionary of aliases for the correct title.</p> required <p>Returns:</p> Type Description <code>float</code> <p><code>float</code>: The highest Levenshtein ratio between the parsed title and any of the correct titles (including aliases if provided).</p> Source code in <code>RTN/extras.py</code> <pre><code>def get_lev_ratio(correct_title: str, parsed_title: str, threshold: float = 0.85, aliases: dict = {}) -&gt; float:\n    \"\"\"\n    Compares two titles using the Levenshtein ratio to determine similarity.\n\n    Args:\n        `correct_title` (str): The reference title to compare against.\n        `parsed_title` (str): The title to compare with the reference title.\n        `threshold` (float): The similarity threshold to consider the titles as matching.\n        `aliases` (dict, optional): A dictionary of aliases for the correct title.\n\n    Returns:\n        `float`: The highest Levenshtein ratio between the parsed title and any of the correct titles (including aliases if provided).\n    \"\"\"\n    if not (correct_title and parsed_title):\n        raise ValueError(\"Both titles must be provided.\")\n    if not isinstance(threshold, (int, float)) or not 0 &lt;= threshold &lt;= 1:\n        raise ValueError(\"The threshold must be a number between 0 and 1.\")\n\n    ratio_set = {\n        ratio(normalize_title(title), normalize_title(parsed_title), score_cutoff=threshold)\n        for title in [normalize_title(correct_title)] + [normalize_title(alias) for alias_list in aliases.values() for alias in alias_list]\n    }\n\n    return max(ratio_set)\n</code></pre>"},{"location":"devs/modules/extras/#RTN.extras.get_resolution","title":"<code>get_resolution(torrent)</code>","text":"<p>Get the resolution of a torrent.</p> <p>Parameters:</p> Name Type Description Default <code>`torrent`</code> <code>Torrent</code> <p>The torrent object to get the resolution of.</p> required <p>Returns:</p> Type Description <code>Resolution</code> <p><code>Resolution</code>: The resolution of the torrent.</p> Source code in <code>RTN/extras.py</code> <pre><code>def get_resolution(torrent: Torrent) -&gt; Resolution:\n    \"\"\"\n    Get the resolution of a torrent.\n\n    Args:\n        `torrent` (Torrent): The torrent object to get the resolution of.\n\n    Returns:\n        `Resolution`: The resolution of the torrent.\n    \"\"\"\n    return RESOLUTION_MAP.get(torrent.data.resolution.lower(), Resolution.UNKNOWN)\n</code></pre>"},{"location":"devs/modules/extras/#RTN.extras.sort_torrents","title":"<code>sort_torrents(torrents, bucket_limit=None, resolutions=[])</code>","text":"<p>Sorts a set of Torrent objects by their resolution bucket and then by their rank in descending order. Returns a dictionary with infohash as keys and Torrent objects as values.</p> <p>Parameters:</p> Name Type Description Default <code>`torrents`</code> <code>Set[Torrent]</code> <p>A set of Torrent objects.</p> required <code>`bucket_limit`</code> <code>int</code> <p>The maximum number of torrents to return from each bucket.</p> required <code>`resolutions`</code> <code>list[Resolution]</code> <p>A list of resolutions to include in the sorting.</p> required <p>Raises:</p> Type Description <code>`TypeError`</code> <p>If the input is not a set of Torrent objects.</p> <p>Returns:</p> Type Description <code>Dict[str, Torrent]</code> <p><code>Dict[str, Torrent]</code>: A dictionary of Torrent objects sorted by resolution and rank in descending order,</p> <code>Dict[str, Torrent]</code> <p>with the torrent's infohash as the key.</p> Source code in <code>RTN/extras.py</code> <pre><code>def sort_torrents(torrents: Set[Torrent], bucket_limit: Optional[int] = None, resolutions: list[Resolution] = []) -&gt; Dict[str, Torrent]:\n    \"\"\"\n    Sorts a set of Torrent objects by their resolution bucket and then by their rank in descending order.\n    Returns a dictionary with infohash as keys and Torrent objects as values.\n\n    Args:\n        `torrents` (Set[Torrent]): A set of Torrent objects.\n        `bucket_limit` (int, optional): The maximum number of torrents to return from each bucket.\n        `resolutions` (list[Resolution], optional): A list of resolutions to include in the sorting.\n\n    Raises:\n        `TypeError`: If the input is not a set of Torrent objects.\n\n    Returns:\n        `Dict[str, Torrent]`: A dictionary of Torrent objects sorted by resolution and rank in descending order,\n        with the torrent's infohash as the key.\n    \"\"\"\n\n    if not isinstance(torrents, set) or not all(isinstance(t, Torrent) for t in torrents):\n        raise TypeError(\"The input must be a set of Torrent objects.\")\n\n    if resolutions:\n        torrents = {t for t in torrents if get_resolution(t) in resolutions}\n\n    sorted_torrents: List[Torrent] = sorted(\n        torrents,\n        key=lambda torrent: (get_resolution(torrent).value, torrent.rank),\n        reverse=True\n    )\n\n    if bucket_limit and bucket_limit &gt; 0:\n        bucket_groups: Dict[Resolution, List[Torrent]] = {}\n        for torrent in sorted_torrents:\n            resolution = get_resolution(torrent)\n            if resolution not in bucket_groups:\n                bucket_groups[resolution] = []\n            bucket_groups[resolution].append(torrent)\n\n        result = {}\n        for bucket_torrents in bucket_groups.values():\n            for torrent in bucket_torrents[:bucket_limit]:\n                result[torrent.infohash] = torrent\n        return result\n\n    return {torrent.infohash: torrent for torrent in sorted_torrents}\n</code></pre>"},{"location":"devs/modules/extras/#RTN.extras.title_match","title":"<code>title_match(correct_title, parsed_title, threshold=0.85, aliases={})</code>","text":"<p>Compares two titles using the Levenshtein ratio to determine similarity.</p> <p>Parameters:</p> Name Type Description Default <code>`correct_title`</code> <code>str</code> <p>The reference title to compare against.</p> required <code>`parsed_title`</code> <code>str</code> <p>The title to compare with the reference title.</p> required <code>`threshold`</code> <code>float</code> <p>The similarity threshold to consider the titles as matching.</p> required <code>`aliases`</code> <code>dict</code> <p>A dictionary of aliases for the correct title.</p> required <p>Returns:     <code>bool</code>: True if the titles match, False otherwise.</p> Source code in <code>RTN/extras.py</code> <pre><code>def title_match(correct_title: str, parsed_title: str, threshold: float = 0.85, aliases: dict = {}) -&gt; bool:\n    \"\"\"\n    Compares two titles using the Levenshtein ratio to determine similarity.\n\n    Args:\n        `correct_title` (str): The reference title to compare against.\n        `parsed_title` (str): The title to compare with the reference title.\n        `threshold` (float): The similarity threshold to consider the titles as matching.\n        `aliases` (dict, optional): A dictionary of aliases for the correct title.\n    Returns:\n        `bool`: True if the titles match, False otherwise.\n    \"\"\"\n    check = get_lev_ratio(correct_title, parsed_title, threshold, aliases)\n    return check &gt;= threshold\n</code></pre>"},{"location":"devs/modules/fetch/","title":"Fetch","text":"<p>This module contains functions to determine if a torrent should be fetched based on user settings.</p> <p>Functions: - <code>check_fetch</code>: Evaluates user settings and unwanted quality to decide if a torrent should be fetched. - <code>check_trash</code>: Identifies if the title contains any unwanted patterns. - <code>trash_handler</code>: Checks if the title is trash based on user settings, return True if trash is detected. - <code>language_handler</code>: Checks if the languages are excluded based on user settings.</p> <p>Parameters: - <code>raw_title</code> (str): The raw title string to evaluate. - <code>data</code> (ParsedData): The parsed data object containing information about the torrent title. - <code>settings</code> (SettingsModel): The user settings object containing custom ranking models.</p> <p>For more information on each function, refer to the respective docstrings.</p>"},{"location":"devs/modules/fetch/#RTN.fetch.adult_handler","title":"<code>adult_handler(data, settings, failed_keys)</code>","text":"<p>Check if the title is adult based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def adult_handler(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the title is adult based on user settings.\"\"\"\n    if data.adult and settings.options.get(\"remove_adult_content\", True):\n        failed_keys.add(\"trash_adult\")\n        return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.check_exclude","title":"<code>check_exclude(data, settings, failed_keys)</code>","text":"<p>Check if the title contains excluded patterns.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def check_exclude(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the title contains excluded patterns.\"\"\"\n    if settings.exclude:\n        for pattern in settings.exclude:\n            if pattern and pattern.search(data.raw_title): # type: ignore\n                failed_keys.add(f\"exclude_regex '{pattern.pattern}'\") # type: ignore\n                return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.check_fetch","title":"<code>check_fetch(data, settings, speed_mode=True)</code>","text":"<p>Check user settings and unwanted quality to determine if torrent should be fetched.</p> <p>Parameters:</p> Name Type Description Default <code>`data`</code> <code>ParsedData</code> <p>The parsed data object containing information about the torrent title.</p> required <code>`settings`</code> <code>SettingsModel</code> <p>The user settings object containing custom ranking models.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>tuple[bool, list]</code> <p>True if the torrent should be fetched, otherwise False.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the parsed data is not a ParsedData object.</p> <code>TypeError</code> <p>If the settings is not a SettingsModel object.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def check_fetch(data: ParsedData, settings: SettingsModel, speed_mode: bool = True) -&gt; tuple[bool, list]:\n    \"\"\"\n    Check user settings and unwanted quality to determine if torrent should be fetched.\n\n    Parameters:\n        `data` (ParsedData): The parsed data object containing information about the torrent title.\n        `settings` (SettingsModel): The user settings object containing custom ranking models.\n\n    Returns:\n        bool: True if the torrent should be fetched, otherwise False.\n\n    Raises:\n        TypeError: If the parsed data is not a ParsedData object.\n        TypeError: If the settings is not a SettingsModel object.\n    \"\"\"\n    if not isinstance(data, ParsedData):\n        raise TypeError(\"Parsed data must be an instance of ParsedData.\")\n    if not isinstance(settings, SettingsModel):\n        raise TypeError(\"Settings must be an instance of SettingsModel.\")\n\n    failed_keys: set[str] = set()\n\n    if speed_mode: # Fail as soon as possible\n        if trash_handler(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if adult_handler(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if check_required(data, settings):\n            return True, list(failed_keys)\n        if check_exclude(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if language_handler(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if fetch_resolution(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if fetch_quality(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if fetch_audio(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if fetch_hdr(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if fetch_codec(data, settings, failed_keys):\n            return False, list(failed_keys)\n        if fetch_other(data, settings, failed_keys):\n            return False, list(failed_keys)\n    else: # Gather all failed keys for more information\n        trash_handler(data, settings, failed_keys)\n        adult_handler(data, settings, failed_keys)\n        check_required(data, settings)\n        check_exclude(data, settings, failed_keys)\n        language_handler(data, settings, failed_keys)\n        fetch_resolution(data, settings, failed_keys)\n        fetch_quality(data, settings, failed_keys)\n        fetch_audio(data, settings, failed_keys)\n        fetch_hdr(data, settings, failed_keys)\n        fetch_codec(data, settings, failed_keys)\n        fetch_other(data, settings, failed_keys)\n\n    if failed_keys:\n        return False, list(failed_keys)\n\n    return True, list(failed_keys)\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.check_required","title":"<code>check_required(data, settings)</code>","text":"<p>Check if the title meets the required patterns.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def check_required(data: ParsedData, settings: SettingsModel) -&gt; bool:\n    \"\"\"Check if the title meets the required patterns.\"\"\"\n    if settings.require and any(pattern.search(data.raw_title) for pattern in settings.require if pattern):  # type: ignore\n        return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.fetch_audio","title":"<code>fetch_audio(data, settings, failed_keys)</code>","text":"<p>Check if the audio is fetchable based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def fetch_audio(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the audio is fetchable based on user settings.\"\"\"\n    if not data.audio:\n        return False\n\n    audio_map = {\n        \"AAC\": \"aac\",\n        # \"OPUS\": \"opus\",\n        \"Atmos\": \"atmos\",\n        \"Dolby Digital\": \"dolby_digital\",\n        \"Dolby Digital Plus\": \"dolby_digital_plus\",\n        \"DTS Lossy\": \"dts_lossy\",\n        \"DTS Lossless\": \"dts_lossless\",\n        # \"PCM\": \"pcm\",\n        \"FLAC\": \"flac\",\n        \"MP3\": \"mp3\",\n        \"TrueHD\": \"truehd\",\n        \"HQ Clean Audio\": \"clean_audio\"\n    }\n\n    for audio_format in data.audio:\n        if audio_format not in audio_map:\n            # PTN parses other audio formats that RTN doesn't support.\n            continue\n\n        category = \"trash\" if audio_format == \"HQ Clean Audio\" else \"audio\"\n        key = audio_map[audio_format]\n        if not settings.custom_ranks[category][key].fetch:\n            failed_keys.add(f\"{category}_{key}\")\n            return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.fetch_codec","title":"<code>fetch_codec(data, settings, failed_keys)</code>","text":"<p>Check if the codec is fetchable based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def fetch_codec(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the codec is fetchable based on user settings.\"\"\"\n    if not data.codec:\n        return False\n\n    if data.codec.lower() in [\"avc\", \"hevc\", \"av1\", \"xvid\", \"mpeg\"]:\n        if not settings.custom_ranks[\"quality\"][data.codec.lower()].fetch:\n            failed_keys.add(f\"codec_{data.codec.lower()}\")\n            return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.fetch_hdr","title":"<code>fetch_hdr(data, settings, failed_keys)</code>","text":"<p>Check if the HDR is fetchable based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def fetch_hdr(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the HDR is fetchable based on user settings.\"\"\"\n    if not data.hdr:\n        return False\n\n    hdr_map = {\n        \"DV\": \"dolby_vision\",\n        \"HDR\": \"hdr\",\n        \"HDR10+\": \"hdr10plus\",\n        \"SDR\": \"sdr\"\n    }\n\n    for hdr_format in data.hdr:\n        if not settings.custom_ranks[\"hdr\"][hdr_map[hdr_format]].fetch:\n            failed_keys.add(f\"hdr_{hdr_map[hdr_format]}\")\n            return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.fetch_other","title":"<code>fetch_other(data, settings, failed_keys)</code>","text":"<p>Check if the other data is fetchable based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def fetch_other(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the other data is fetchable based on user settings.\"\"\"\n    fetch_map = {\n        \"_3d\": (\"extras\", \"three_d\"),\n        \"converted\": (\"extras\", \"converted\"),\n        \"documentary\": (\"extras\", \"documentary\"),\n        \"dubbed\": (\"extras\", \"dubbed\"),\n        \"edition\": (\"extras\", \"edition\"),\n        \"hardcoded\": (\"extras\", \"hardcoded\"),\n        \"network\": (\"extras\", \"network\"),\n        \"proper\": (\"extras\", \"proper\"),\n        \"repack\": (\"extras\", \"repack\"),\n        \"retail\": (\"extras\", \"retail\"),\n        \"subbed\": (\"extras\", \"subbed\"),\n        \"upscaled\": (\"extras\", \"upscaled\"),\n        \"site\": (\"extras\", \"site\"),\n        \"size\": (\"trash\", \"size\"),\n        \"bit_depth\": (\"hdr\", \"10bit\"),\n        \"scene\": (\"extras\", \"scene\"),\n        \"uncensored\": (\"extras\", \"uncensored\")\n    }\n\n    for attr, (category, key) in fetch_map.items():\n        if getattr(data, attr) and not settings.custom_ranks[category][key].fetch:\n            failed_keys.add(f\"{category}_{key}\")\n            return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.fetch_quality","title":"<code>fetch_quality(data, settings, failed_keys)</code>","text":"<p>Check if the quality is fetchable based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def fetch_quality(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the quality is fetchable based on user settings.\"\"\"\n    if not data.quality:\n        return False\n\n    quality_map = {\n        # parse result, (settings location, settings key)\n        \"WEB\": (\"quality\", \"web\"),\n        \"WEB-DL\": (\"quality\", \"webdl\"),\n        \"BluRay\": (\"quality\", \"bluray\"),\n        \"HDTV\": (\"quality\", \"hdtv\"),\n        \"VHS\": (\"quality\", \"vhs\"),\n        \"WEBMux\": (\"quality\", \"webmux\"),\n        \"BluRay REMUX\": (\"quality\", \"remux\"),\n        \"REMUX\": (\"quality\", \"remux\"),\n        \"WEBRip\": (\"rips\", \"webrip\"),\n        \"WEB-DLRip\": (\"rips\", \"webdlrip\"),\n        \"UHDRip\": (\"rips\", \"uhdrip\"),\n        \"HDRip\": (\"rips\", \"hdrip\"),\n        \"DVDRip\": (\"rips\", \"dvdrip\"),\n        \"BDRip\": (\"rips\", \"bdrip\"),\n        \"BRRip\": (\"rips\", \"brrip\"),\n        \"VHSRip\": (\"rips\", \"vhsrip\"),\n        \"PPVRip\": (\"rips\", \"ppvrip\"),\n        \"SATRip\": (\"rips\", \"satrip\"),\n        \"TeleCine\": (\"trash\", \"telecine\"),\n        \"TeleSync\": (\"trash\", \"telesync\"),\n        \"SCR\": (\"trash\", \"screener\"),\n        \"R5\": (\"trash\", \"r5\"),\n        \"CAM\": (\"trash\", \"cam\"),\n        \"PDTV\": (\"trash\", \"pdtv\")\n    }\n\n    category, key = quality_map.get(data.quality, (None, None))\n    if category and key:\n        if not settings.custom_ranks[category][key].fetch:\n            failed_keys.add(f\"{category}_{key}\")\n            return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.fetch_resolution","title":"<code>fetch_resolution(data, settings, failed_keys)</code>","text":"<p>Check if the resolution is fetchable based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def fetch_resolution(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the resolution is fetchable based on user settings.\"\"\"\n    if not data.resolution:\n        if not settings.resolutions[\"unknown\"]:\n            failed_keys.add(\"resolution_unknown\")\n            return True\n        return False\n\n    res_map = {\n        \"2160p\": \"2160p\", \"4k\": \"2160p\",\n        \"1080p\": \"1080p\", \"1440p\": \"1080p\",\n        \"720p\": \"720p\",\n        \"480p\": \"480p\", \"576p\": \"480p\",\n        \"360p\": \"360p\", \"240p\": \"360p\"\n    }\n\n    res_key = res_map.get(data.resolution.lower(), \"unknown\")\n    if not settings.resolutions[res_key]:\n        failed_keys.add(f\"resolution\")\n        return True\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.language_handler","title":"<code>language_handler(data, settings, failed_keys)</code>","text":"<p>Check if the languages are excluded based on user settings.</p> <p>Logic: 1. If no languages detected and remove_unknown_languages is True -&gt; exclude 2. If no languages detected and required is set -&gt; exclude 3. If required languages are set and torrent has NONE of them -&gt; exclude 4. If allow_english_in_languages is True and torrent has English -&gt; accept 5. If torrent has any allowed language -&gt; accept (bypass exclusion check) 6. If torrent has any excluded language -&gt; exclude 7. Otherwise -&gt; accept</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the languages should be excluded, otherwise False.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def language_handler(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"\n    Check if the languages are excluded based on user settings.\n\n    Logic:\n    1. If no languages detected and remove_unknown_languages is True -&gt; exclude\n    2. If no languages detected and required is set -&gt; exclude\n    3. If required languages are set and torrent has NONE of them -&gt; exclude\n    4. If allow_english_in_languages is True and torrent has English -&gt; accept\n    5. If torrent has any allowed language -&gt; accept (bypass exclusion check)\n    6. If torrent has any excluded language -&gt; exclude\n    7. Otherwise -&gt; accept\n\n    Returns:\n        bool: True if the languages should be excluded, otherwise False.\n    \"\"\"\n    populate_langs(settings)\n\n    remove_unknown = settings.options.get(\"remove_unknown_languages\", False)\n    required_langs = settings.languages.get(\"required\", [])\n    allowed_langs = settings.languages.get(\"allowed\", [])\n    exclude_langs = settings.languages.get(\"exclude\", [])\n\n    if not data.languages:\n        if remove_unknown:\n            failed_keys.add(\"unknown_language\")\n            return True\n        if required_langs:\n            failed_keys.add(\"missing_required_language\")\n            return True\n        return False\n\n    if required_langs and not any(lang in required_langs for lang in data.languages):\n        failed_keys.add(\"missing_required_language\")\n        return True\n\n    if \"en\" in data.languages and settings.options.get(\"allow_english_in_languages\", False):\n        return False\n\n    if allowed_langs and any(lang in allowed_langs for lang in data.languages):\n        return False\n\n    excluded = [lang for lang in data.languages if lang in exclude_langs]\n    if excluded:\n        for lang in excluded:\n            failed_keys.add(f\"lang_{lang}\")\n        return True\n\n    return False\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.populate_langs","title":"<code>populate_langs(settings)</code>","text":"<p>Populate the languages based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def populate_langs(settings: SettingsModel) -&gt; None:\n    \"\"\"Populate the languages based on user settings.\"\"\"\n    exclude_langs = set(settings.languages.get(\"exclude\", []))\n    required_langs = set(settings.languages.get(\"required\", []))\n    allowed_langs = set(settings.languages.get(\"allowed\", []))\n\n    language_groups = {\n        \"anime\": ANIME,\n        \"non_anime\": NON_ANIME,\n        \"common\": COMMON,\n        \"all\": ALL\n    }\n\n    for lang_group, lang_set in language_groups.items():\n        if lang_group in exclude_langs:\n            exclude_langs.update(lang_set)\n        if lang_group in required_langs:\n            required_langs.update(lang_set)\n        if lang_group in allowed_langs:\n            allowed_langs.update(lang_set)\n\n    settings.languages.exclude = list(exclude_langs)\n    settings.languages.required = list(required_langs)\n    settings.languages.allowed = list(allowed_langs)\n</code></pre>"},{"location":"devs/modules/fetch/#RTN.fetch.trash_handler","title":"<code>trash_handler(data, settings, failed_keys)</code>","text":"<p>Check if the title is trash based on user settings.</p> Source code in <code>RTN/fetch.py</code> <pre><code>def trash_handler(data: ParsedData, settings: SettingsModel, failed_keys: set) -&gt; bool:\n    \"\"\"Check if the title is trash based on user settings.\"\"\"\n    if settings.options[\"remove_all_trash\"]:\n        if data.quality in [\"CAM\", \"PDTV\", \"R5\", \"SCR\", \"TeleCine\", \"TeleSync\"]:\n            failed_keys.add(\"trash_quality\")\n            return True\n        if \"HQ Clean Audio\" in data.audio:\n            failed_keys.add(\"trash_audio\")\n            return True\n        if hasattr(data, \"trash\") and data.trash:\n            failed_keys.add(\"trash_flag\")\n            return True\n    return False\n</code></pre>"},{"location":"devs/modules/models/","title":"Models","text":"<p>This module contains models used in the RTN package for parsing torrent titles, ranking media quality, and defining user settings.</p> <p>Models: - <code>ParsedData</code>: Model for storing parsed information from a torrent title. - <code>BaseRankingModel</code>: Base class for ranking models used in the context of media quality and attributes. - <code>Torrent</code>: Model for representing a torrent with metadata parsed from its title and additional computed properties. - <code>DefaultRanking</code>: Ranking model preset that prioritizes the highest quality and most desirable attributes. - <code>CustomRank</code>: Model used in the <code>SettingsModel</code> for defining custom ranks for specific attributes. - <code>SettingsModel</code>: User-defined settings model for ranking torrents, including preferences for filtering torrents based on regex patterns and customizing ranks for specific torrent attributes.</p> <p>For more information on each model, refer to the respective docstrings.</p> <p>Note: - The <code>ParsedData</code> model contains attributes for storing parsed information from a torrent title. - The <code>BaseRankingModel</code> model is a base class for ranking models used in the context of media quality and attributes. - The <code>CustomRank</code> model is used in the <code>SettingsModel</code> for defining custom ranks for specific attributes. - The <code>SettingsModel</code> model allows users to define custom settings for ranking torrents based on quality attributes and regex patterns.</p>"},{"location":"devs/modules/models/#RTN.models.AudioRankModel","title":"<code>AudioRankModel</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Ranking configuration for audio attributes.</p> Source code in <code>RTN/models.py</code> <pre><code>class AudioRankModel(ConfigModelBase):\n    \"\"\"Ranking configuration for audio attributes.\"\"\"\n    aac: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    atmos: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dolby_digital: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dolby_digital_plus: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dts_lossy: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dts_lossless: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    # opus: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    # pcm: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    flac: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    mono: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    mp3: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    stereo: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    surround: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    truehd: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.BaseRankingModel","title":"<code>BaseRankingModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for ranking models used in the context of media quality and attributes. The ranking values are used to determine the quality of a media item based on its attributes.</p> Note <ul> <li>The higher the ranking value, the better the quality of the media item.</li> <li>The default ranking values are set to 0, which means that the attribute does not affect the overall rank.</li> <li>Users can customize the ranking values based on their preferences and requirements by using inheritance.</li> </ul> Source code in <code>RTN/models.py</code> <pre><code>class BaseRankingModel(BaseModel):\n    \"\"\"\n    A base class for ranking models used in the context of media quality and attributes.\n    The ranking values are used to determine the quality of a media item based on its attributes.\n\n    Note:\n        - The higher the ranking value, the better the quality of the media item.\n        - The default ranking values are set to 0, which means that the attribute does not affect the overall rank.\n        - Users can customize the ranking values based on their preferences and requirements by using inheritance.\n    \"\"\"\n    # quality\n    av1: int = 0\n    avc: int = 0\n    bluray: int = 0\n    dvd: int = 0\n    hdtv: int = 0\n    hevc: int = 0\n    mpeg: int = 0\n    remux: int = 0\n    vhs: int = 0\n    web: int = 0\n    webdl: int = 0\n    webmux: int = 0\n    xvid: int = 0\n\n    # rips\n    bdrip: int = 0\n    brrip: int = 0\n    dvdrip: int = 0\n    hdrip: int = 0\n    ppvrip: int = 0\n    tvrip: int = 0\n    uhdrip: int = 0\n    vhsrip: int = 0\n    webdlrip: int = 0\n    webrip: int = 0\n\n    # hdr\n    bit_10: int = 0\n    dolby_vision: int = 0\n    hdr: int = 0\n    hdr10plus: int = 0\n    sdr: int = 0\n\n    # audio\n    aac: int = 0\n    atmos: int = 0\n    dolby_digital: int = 0\n    dolby_digital_plus: int = 0\n    dts_lossy: int = 0\n    dts_lossless: int = 0\n    # opus: int = 0\n    # pcm: int = 0\n    flac: int = 0\n    mono: int = 0\n    mp3: int = 0\n    stereo: int = 0\n    surround: int = 0\n    truehd: int = 0\n\n    # extras\n    three_d: int = 0\n    converted: int = 0\n    documentary: int = 0\n    commentary: int = 0\n    uncensored: int = 0\n    dubbed: int = 0\n    edition: int = 0\n    hardcoded: int = 0\n    network: int = 0\n    proper: int = 0\n    repack: int = 0\n    retail: int = 0\n    subbed: int = 0\n    upscaled: int = 0\n    scene: int = 0\n\n    # trash\n    cam: int = 0\n    clean_audio: int = 0\n    r5: int = 0\n    pdtv: int = 0\n    satrip: int = 0\n    screener: int = 0\n    site: int = 0\n    size: int = 0\n    telecine: int = 0\n    telesync: int = 0\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.ConfigModelBase","title":"<code>ConfigModelBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for config models that need dict-like behavior</p> Source code in <code>RTN/models.py</code> <pre><code>class ConfigModelBase(BaseModel):\n    \"\"\"Base class for config models that need dict-like behavior\"\"\"\n    def __getitem__(self, key: str) -&gt; Any:\n        return getattr(self, key)\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        try:\n            return self[key]\n        except (KeyError, AttributeError):\n            return default\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.CustomRank","title":"<code>CustomRank</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Custom Ranks used in SettingsModel.</p> Source code in <code>RTN/models.py</code> <pre><code>class CustomRank(BaseModel):\n    \"\"\"Custom Ranks used in SettingsModel.\"\"\"\n    fetch: bool = Field(default=True)\n    use_custom_rank: bool = Field(default=False)\n    rank: int = Field(default=0)\n\n    def model_dump(self, **kwargs) -&gt; Dict[str, Any]:\n        \"\"\"Ensure serialization consistency.\"\"\"\n        return super().model_dump(**kwargs)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.CustomRank.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Ensure serialization consistency.</p> Source code in <code>RTN/models.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; Dict[str, Any]:\n    \"\"\"Ensure serialization consistency.\"\"\"\n    return super().model_dump(**kwargs)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.CustomRanksConfig","title":"<code>CustomRanksConfig</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Configuration for custom ranks.</p> Source code in <code>RTN/models.py</code> <pre><code>class CustomRanksConfig(ConfigModelBase):\n    \"\"\"Configuration for custom ranks.\"\"\"\n    quality: QualityRankModel = Field(default_factory=QualityRankModel)\n    rips: RipsRankModel = Field(default_factory=RipsRankModel)\n    hdr: HdrRankModel = Field(default_factory=HdrRankModel)\n    audio: AudioRankModel = Field(default_factory=AudioRankModel)\n    extras: ExtrasRankModel = Field(default_factory=ExtrasRankModel)\n    trash: TrashRankModel = Field(default_factory=TrashRankModel)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.DefaultRanking","title":"<code>DefaultRanking</code>","text":"<p>               Bases: <code>BaseRankingModel</code></p> <p>Ranking model preset that covers the highest qualities like 4K HDR.</p> Source code in <code>RTN/models.py</code> <pre><code>class DefaultRanking(BaseRankingModel):\n    \"\"\"Ranking model preset that covers the highest qualities like 4K HDR.\"\"\"\n\n    # quality\n    av1: int = 500\n    avc: int = 500\n    bluray: int = 100\n    dvd: int = -5000\n    hdtv: int = -5000\n    hevc: int = 500\n    mpeg: int = -1000\n    remux: int = 10000\n    vhs: int = -10000\n    web: int = 100\n    webdl: int = 200\n    webmux: int = -10000\n    xvid: int = -10000\n    pdtv: int = -10000\n\n    # rips\n    bdrip: int = -5000\n    brrip: int = -10000\n    dvdrip: int = -5000\n    hdrip: int = -10000\n    ppvrip: int = -10000\n    tvrip: int = -10000\n    uhdrip: int = -5000\n    vhsrip: int = -10000\n    webdlrip: int = -10000\n    webrip: int = -1000\n\n    # hdr\n    bit_10: int = 100\n    dolby_vision: int = 3000\n    hdr: int = 2000\n    hdr10plus: int = 2100\n\n    # audio\n    aac: int = 100\n    atmos: int = 1000\n    dolby_digital: int = 50\n    dolby_digital_plus: int = 150\n    dts_lossy: int = 100\n    dts_lossless: int = 2000\n    mp3: int = -1000\n    truehd: int = 2000\n\n    # extras\n    three_d: int = -10000\n    converted: int = -1000\n    documentary: int = -250\n    dubbed: int = -1000\n    edition: int = 100\n    proper: int = 20\n    repack: int = 20\n    site: int = -10000\n    upscaled: int = -10000\n\n    # trash\n    cam: int = -10000\n    clean_audio: int = -10000\n    r5: int = -10000\n    satrip: int = -10000\n    screener: int = -10000\n    size: int = -10000\n    telecine: int = -10000\n    telesync: int = -10000\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.ExtrasRankModel","title":"<code>ExtrasRankModel</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Ranking configuration for extras attributes.</p> Source code in <code>RTN/models.py</code> <pre><code>class ExtrasRankModel(ConfigModelBase):\n    \"\"\"Ranking configuration for extras attributes.\"\"\"\n    three_d: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False), alias=\"3d\")\n    converted: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    documentary: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    dubbed: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    edition: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    hardcoded: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    network: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    proper: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    repack: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    retail: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    site: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    subbed: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    upscaled: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    scene: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    uncensored: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        alias_generator=lambda field_name: \"3d\" if field_name == \"three_d\" else field_name\n    )\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.HdrRankModel","title":"<code>HdrRankModel</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Ranking configuration for HDR attributes.</p> Source code in <code>RTN/models.py</code> <pre><code>class HdrRankModel(ConfigModelBase):\n    \"\"\"Ranking configuration for HDR attributes.\"\"\"\n    def __getitem__(self, key: str) -&gt; Any:\n        # Special handling for '10bit' key\n        if key == '10bit':\n            return self.bit10\n        return super().__getitem__(key)\n\n    bit10: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dolby_vision: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    hdr: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    hdr10plus: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    sdr: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.LanguagesConfig","title":"<code>LanguagesConfig</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Configuration for which languages are enabled.</p> <p>Attributes:</p> Name Type Description <code>required</code> <code>List[str]</code> <p>Languages that MUST be present in the torrent. If set, torrents without       at least one of these languages will be excluded.</p> <code>allowed</code> <code>List[str]</code> <p>Languages that bypass the exclusion logic. If a torrent contains any of      these languages, it won't be excluded even if it also contains excluded languages.</p> <code>exclude</code> <code>List[str]</code> <p>Languages that should be excluded from results.</p> <code>preferred</code> <code>List[str]</code> <p>Languages that are preferred (used for ranking).</p> Source code in <code>RTN/models.py</code> <pre><code>class LanguagesConfig(ConfigModelBase):\n    \"\"\"Configuration for which languages are enabled.\n\n    Attributes:\n        required: Languages that MUST be present in the torrent. If set, torrents without\n                  at least one of these languages will be excluded.\n        allowed: Languages that bypass the exclusion logic. If a torrent contains any of\n                 these languages, it won't be excluded even if it also contains excluded languages.\n        exclude: Languages that should be excluded from results.\n        preferred: Languages that are preferred (used for ranking).\n    \"\"\"\n    required: List[str] = Field(default=[])\n    allowed: List[str] = Field(default=[])\n    exclude: List[str] = Field(default=[])\n    preferred: List[str] = Field(default=[])\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.OptionsConfig","title":"<code>OptionsConfig</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Configuration for various options.</p> Source code in <code>RTN/models.py</code> <pre><code>class OptionsConfig(ConfigModelBase):\n    \"\"\"Configuration for various options.\"\"\"\n    title_similarity: float = Field(default=0.85)\n    remove_all_trash: bool = Field(default=True)\n    remove_ranks_under: int = Field(default=-10000)\n    remove_unknown_languages: bool = Field(default=False)\n    allow_english_in_languages: bool = Field(default=True)\n    enable_fetch_speed_mode: bool = Field(default=True)\n    remove_adult_content: bool = Field(default=True)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.ParsedData","title":"<code>ParsedData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parsed data model for a torrent title.</p> Source code in <code>RTN/models.py</code> <pre><code>class ParsedData(BaseModel):\n    \"\"\"Parsed data model for a torrent title.\"\"\"\n\n    raw_title: str\n    parsed_title: str = \"\"\n    normalized_title: str = \"\"\n    trash: bool = False\n    adult: bool = False\n    year: Optional[int] = None\n    resolution: str = \"unknown\"\n    seasons: List[int] = []\n    episodes: List[int] = []\n    complete: bool = False\n    volumes: List[int] = []\n    languages: List[str] = []\n    quality: Optional[str] = None\n    hdr: List[str] = []\n    codec: Optional[str] = None\n    audio: List[str] = []\n    channels: List[str] = []\n    dubbed: bool = False\n    subbed: bool = False\n    date: Optional[str] = None\n    group: Optional[str] = None\n    edition: Optional[str] = None\n    bit_depth: Optional[str] = None\n    bitrate: Optional[str] = None\n    network: Optional[str] = None\n    extended: bool = False\n    converted: bool = False\n    hardcoded: bool = False\n    region: Optional[str] = None\n    ppv: bool = False\n    _3d: bool = False\n    site: Optional[str] = None\n    size: Optional[str] = None\n    proper: bool = False\n    repack: bool = False\n    retail: bool = False\n    upscaled: bool = False\n    remastered: bool = False\n    unrated: bool = False\n    uncensored: bool = False\n    documentary: bool = False\n    commentary: bool = False\n    episode_code: Optional[str] = None\n    country: Optional[str] = None\n    container: Optional[str] = None\n    extension: Optional[str] = None\n    extras: List[str] = []\n    torrent: bool = False\n    scene: bool = False\n\n    class Config:\n        from_attributes = True\n        use_orm = True\n\n    @property\n    def type(self) -&gt; str:\n        \"\"\"Returns the type of the torrent based on its attributes.\"\"\"\n        if not self.seasons and not self.episodes:\n            return \"movie\"\n        return \"show\"\n\n    def to_dict(self):\n        return self.model_dump_json()\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.ParsedData.type","title":"<code>type</code>  <code>property</code>","text":"<p>Returns the type of the torrent based on its attributes.</p>"},{"location":"devs/modules/models/#RTN.models.QualityRankModel","title":"<code>QualityRankModel</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Ranking configuration for quality attributes.</p> Source code in <code>RTN/models.py</code> <pre><code>class QualityRankModel(ConfigModelBase):\n    \"\"\"Ranking configuration for quality attributes.\"\"\"\n    av1: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    avc: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    bluray: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dvd: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    hdtv: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    hevc: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    mpeg: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    remux: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    vhs: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    web: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    webdl: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    webmux: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    xvid: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.ResolutionConfig","title":"<code>ResolutionConfig</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Configuration for which resolutions are enabled.</p> Source code in <code>RTN/models.py</code> <pre><code>class ResolutionConfig(ConfigModelBase):\n    \"\"\"Configuration for which resolutions are enabled.\"\"\"\n    def __getitem__(self, key: str) -&gt; Any:\n        # Special handling for resolution fields - add 'r' prefix\n        field_name = f\"r{key}\" if key.endswith('p') else key\n        return getattr(self, field_name)\n\n    r2160p: bool = Field(default=False)\n    r1080p: bool = Field(default=True)\n    r720p: bool = Field(default=True)\n    r480p: bool = Field(default=False)\n    r360p: bool = Field(default=False)\n    unknown: bool = Field(default=True)\n\n    model_config = ConfigDict(\n        populate_by_name=True\n    )\n\n    def json(self, **kwargs) -&gt; str:\n        \"\"\"Ensure alias serialization for JSON output\"\"\"\n        return super().model_dump_json(by_alias=True, **kwargs)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.ResolutionConfig.json","title":"<code>json(**kwargs)</code>","text":"<p>Ensure alias serialization for JSON output</p> Source code in <code>RTN/models.py</code> <pre><code>def json(self, **kwargs) -&gt; str:\n    \"\"\"Ensure alias serialization for JSON output\"\"\"\n    return super().model_dump_json(by_alias=True, **kwargs)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.RipsRankModel","title":"<code>RipsRankModel</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Ranking configuration for rips attributes.</p> Source code in <code>RTN/models.py</code> <pre><code>class RipsRankModel(ConfigModelBase):\n    \"\"\"Ranking configuration for rips attributes.\"\"\"\n    bdrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    brrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    dvdrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    hdrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n    ppvrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    satrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    tvrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    uhdrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    vhsrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    webdlrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    webrip: CustomRank = Field(default_factory=lambda: CustomRank(fetch=True))\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel","title":"<code>SettingsModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents user-defined settings for ranking torrents, including preferences for filtering torrents based on regex patterns and customizing ranks for specific torrent attributes.</p> <p>Attributes:</p> Name Type Description <code>require</code> <code>List[str | Pattern]</code> <p>Patterns torrents must match to be considered.</p> <code>exclude</code> <code>List[str | Pattern]</code> <p>Patterns that, if matched, result in torrent exclusion.</p> <code>preferred</code> <code>List[str | Pattern]</code> <p>Patterns indicating preferred attributes in torrents. Given +10000 points by default.</p> <code>resolutions</code> <code>ResolutionConfig</code> <p>Configuration for which resolutions are enabled.</p> <code>options</code> <code>OptionsConfig</code> <p>Configuration for various options like title similarity and trash removal.</p> <code>languages</code> <code>LanguagesConfig</code> <p>Configuration for which languages are enabled, excluded, and preferred.</p> <code>custom_ranks</code> <code>CustomRanksConfig</code> <p>Custom ranking configurations for specific attributes.</p> <p>Methods:</p> Name Description <code>compile_and_validate_patterns</code> <p>Compiles string patterns to regex.Pattern objects, handling case sensitivity.</p> Note <ul> <li>Patterns enclosed in '/' are compiled as case-sensitive.</li> <li>Patterns not enclosed are compiled as case-insensitive by default.</li> <li>The model supports advanced regex features for precise filtering and ranking.</li> </ul> Example <p>settings = SettingsModel( ...     require=[\"\\b4K|1080p\\b\", \"720p\"], ...     exclude=[\"CAM\", \"TS\"], ...     preferred=[\"BluRay\", r\"/\\bS\\d+/\", \"/HDR|HDR10/\"], ...     resolutions=ResolutionConfig(r1080p=True, r720p=True), ...     options=OptionsConfig(remove_all_trash=True), ...     languages=LanguagesConfig(required=[\"en\"]), ...     custom_ranks=CustomRanksConfig() ... ) print([p.pattern for p in settings.require]) ['\\b4K|1080p\\b', '720p'] print(settings.resolutions.r1080p) True print(settings.options.remove_all_trash) True</p> Source code in <code>RTN/models.py</code> <pre><code>class SettingsModel(BaseModel):\n    \"\"\"\n    Represents user-defined settings for ranking torrents, including preferences for filtering torrents\n    based on regex patterns and customizing ranks for specific torrent attributes.\n\n    Attributes:\n        require (List[str | Pattern]): Patterns torrents must match to be considered.\n        exclude (List[str | Pattern]): Patterns that, if matched, result in torrent exclusion.\n        preferred (List[str | Pattern]): Patterns indicating preferred attributes in torrents. Given +10000 points by default.\n        resolutions (ResolutionConfig): Configuration for which resolutions are enabled.\n        options (OptionsConfig): Configuration for various options like title similarity and trash removal.\n        languages (LanguagesConfig): Configuration for which languages are enabled, excluded, and preferred.\n        custom_ranks (CustomRanksConfig): Custom ranking configurations for specific attributes.\n\n    Methods:\n        compile_and_validate_patterns: Compiles string patterns to regex.Pattern objects, handling case sensitivity.\n\n    Note:\n        - Patterns enclosed in '/' are compiled as case-sensitive.\n        - Patterns not enclosed are compiled as case-insensitive by default.\n        - The model supports advanced regex features for precise filtering and ranking.\n\n    Example:\n        &gt;&gt;&gt; settings = SettingsModel(\n        ...     require=[\"\\\\b4K|1080p\\\\b\", \"720p\"],\n        ...     exclude=[\"CAM\", \"TS\"],\n        ...     preferred=[\"BluRay\", r\"/\\\\bS\\\\d+/\", \"/HDR|HDR10/\"],\n        ...     resolutions=ResolutionConfig(r1080p=True, r720p=True),\n        ...     options=OptionsConfig(remove_all_trash=True),\n        ...     languages=LanguagesConfig(required=[\"en\"]),\n        ...     custom_ranks=CustomRanksConfig()\n        ... )\n        &gt;&gt;&gt; print([p.pattern for p in settings.require])\n        ['\\\\b4K|1080p\\\\b', '720p']\n        &gt;&gt;&gt; print(settings.resolutions.r1080p)\n        True\n        &gt;&gt;&gt; print(settings.options.remove_all_trash)\n        True\n    \"\"\"\n    name: str = Field(\n        default=\"example\",\n        description=\"Name of the settings\"\n    )\n    enabled: bool = Field(\n        default=True,\n        description=\"Whether these settings will be used or not\"\n    )\n    require: List[PatternType] = Field(\n        default=[],\n        description=\"Patterns torrents must match to be considered\"\n    )\n    exclude: List[PatternType] = Field(\n        default=[],\n        description=\"Patterns that, if matched, result in torrent exclusion\"\n    )\n    preferred: List[PatternType] = Field(\n        default=[],\n        description=\"Patterns indicating preferred attributes in torrents\"\n    )\n    resolutions: ResolutionConfig = Field(\n        default_factory=ResolutionConfig,\n        description=\"Configuration for enabled resolutions\"\n    )\n    options: OptionsConfig = Field(\n        default_factory=OptionsConfig,\n        description=\"General options for torrent filtering and ranking\"\n    )\n    languages: LanguagesConfig = Field(\n        default_factory=LanguagesConfig,\n        description=\"Language preferences and restrictions\"\n    )\n    custom_ranks: CustomRanksConfig = Field(\n        default_factory=CustomRanksConfig,\n        description=\"Custom ranking configurations for specific attributes\"\n    )\n\n    @model_validator(mode=\"before\")\n    def compile_and_validate_patterns(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Compile string patterns to regex.Pattern, keeping compiled patterns unchanged.\"\"\"\n\n        def compile_pattern(pattern: PatternType) -&gt; Pattern:\n            \"\"\"Helper function to compile a single pattern.\"\"\"\n            if isinstance(pattern, str):\n                if pattern.startswith(\"/\") and pattern.endswith(\"/\"):  # case-sensitive\n                    return regex.compile(pattern[1:-1])\n                return regex.compile(pattern, regex.IGNORECASE)  # case-insensitive\n            elif isinstance(pattern, Pattern):\n                return pattern  # Keep already compiled patterns as is\n            raise ValueError(f\"Invalid pattern type: {type(pattern)}\")\n\n        for field in (\"require\", \"exclude\", \"preferred\"):\n            if field not in values or values[field] is None:\n                values[field] = []\n            elif isinstance(values[field], (list, tuple)):\n                values[field] = [compile_pattern(p) for p in values[field]]\n\n        return values\n\n    @field_serializer(\"require\", \"exclude\", \"preferred\", when_used=\"always\")\n    def serialize_patterns(self, values: List[PatternType]) -&gt; List[str]:\n        \"\"\"Convert regex patterns to strings for JSON serialization.\"\"\"\n        return [v.pattern if isinstance(v, regex.Pattern) else v for v in values]\n\n    @field_validator(\"require\", \"exclude\", \"preferred\", mode=\"before\")\n    @classmethod\n    def deserialize_patterns(cls, values: List[Union[str, PatternType]]) -&gt; List[PatternType]:\n        \"\"\"Convert string patterns back to compiled regex.\"\"\"\n        return [regex.compile(v) if isinstance(v, str) else v for v in values]\n\n    def __getitem__(self, item: str) -&gt; CustomRankDict:\n        \"\"\"Access custom rank settings via attribute keys.\"\"\"\n        return self.custom_ranks[item]\n\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        from_attributes=True,\n        json_encoders={\n            Pattern: lambda v: f\"/{v.pattern}/\" if not v.flags &amp; regex.IGNORECASE else v.pattern\n        }\n    )\n\n    def save(self, path: Union[str, Path]) -&gt; None:\n        \"\"\"\n        Save settings to a JSON file.\n\n        Args:\n            path: Path where the settings file should be saved.\n                 Can be either a string or Path object.\n\n        Example:\n            &gt;&gt;&gt; settings = SettingsModel()\n            &gt;&gt;&gt; settings.save(\"my_settings.json\")\n            &gt;&gt;&gt; settings.save(Path(\"configs/my_settings.json\"))\n        \"\"\"\n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        with path.open('w', encoding='utf-8') as f:\n            json.dump(self.model_dump(mode='json'), f, indent=4)\n\n    @classmethod\n    def load(cls, path: Union[str, Path]) -&gt; 'SettingsModel':\n        \"\"\"\n        Load settings from a JSON file.\n\n        Args:\n            path: Path to the settings file.\n\n        Returns:\n            SettingsModel: A new settings instance with the loaded configuration.\n\n        Raises:\n            FileNotFoundError: If the settings file doesn't exist.\n            JSONDecodeError: If the settings file is corrupted or contains invalid JSON.\n            ValidationError: If the settings file contains invalid configuration.\n        \"\"\"\n        path = Path(path)\n\n        if not path.exists():\n            raise FileNotFoundError(f\"Settings file not found: {path}\")\n\n        with path.open('r', encoding='utf-8') as f:\n            data = json.load(f)\n\n        return cls.model_validate(data)\n\n    @classmethod\n    def load_or_default(cls, path: Optional[Union[str, Path]] = None) -&gt; 'SettingsModel':\n        \"\"\"\n        Load settings from a file if it exists, otherwise create default settings and save them.\n\n        Args:\n            path: Optional path to the settings file.\n                If None, returns default settings without saving.\n\n        Returns:\n            SettingsModel: Either the loaded settings or default settings.\n\n        Raises:\n            JSONDecodeError: If the settings file is corrupted or contains invalid JSON.\n        \"\"\"\n        if path is None:\n            return cls()\n\n        path = Path(path)\n        try:\n            return cls.load(path)\n        except FileNotFoundError:\n            settings = cls()\n            settings.save(path)\n            return settings\n\n    def changed_only(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Compare the provided settings with the default settings and return only the changed fields.\n\n        Args:\n            settings: The settings to compare against the default.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing only the changed fields and their values.\n        \"\"\"\n        return self.model_dump(mode='json', exclude_unset=True, exclude_defaults=True)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Access custom rank settings via attribute keys.</p> Source code in <code>RTN/models.py</code> <pre><code>def __getitem__(self, item: str) -&gt; CustomRankDict:\n    \"\"\"Access custom rank settings via attribute keys.\"\"\"\n    return self.custom_ranks[item]\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.changed_only","title":"<code>changed_only()</code>","text":"<p>Compare the provided settings with the default settings and return only the changed fields.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>The settings to compare against the default.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing only the changed fields and their values.</p> Source code in <code>RTN/models.py</code> <pre><code>def changed_only(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Compare the provided settings with the default settings and return only the changed fields.\n\n    Args:\n        settings: The settings to compare against the default.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing only the changed fields and their values.\n    \"\"\"\n    return self.model_dump(mode='json', exclude_unset=True, exclude_defaults=True)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.compile_and_validate_patterns","title":"<code>compile_and_validate_patterns(values)</code>","text":"<p>Compile string patterns to regex.Pattern, keeping compiled patterns unchanged.</p> Source code in <code>RTN/models.py</code> <pre><code>@model_validator(mode=\"before\")\ndef compile_and_validate_patterns(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Compile string patterns to regex.Pattern, keeping compiled patterns unchanged.\"\"\"\n\n    def compile_pattern(pattern: PatternType) -&gt; Pattern:\n        \"\"\"Helper function to compile a single pattern.\"\"\"\n        if isinstance(pattern, str):\n            if pattern.startswith(\"/\") and pattern.endswith(\"/\"):  # case-sensitive\n                return regex.compile(pattern[1:-1])\n            return regex.compile(pattern, regex.IGNORECASE)  # case-insensitive\n        elif isinstance(pattern, Pattern):\n            return pattern  # Keep already compiled patterns as is\n        raise ValueError(f\"Invalid pattern type: {type(pattern)}\")\n\n    for field in (\"require\", \"exclude\", \"preferred\"):\n        if field not in values or values[field] is None:\n            values[field] = []\n        elif isinstance(values[field], (list, tuple)):\n            values[field] = [compile_pattern(p) for p in values[field]]\n\n    return values\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.deserialize_patterns","title":"<code>deserialize_patterns(values)</code>  <code>classmethod</code>","text":"<p>Convert string patterns back to compiled regex.</p> Source code in <code>RTN/models.py</code> <pre><code>@field_validator(\"require\", \"exclude\", \"preferred\", mode=\"before\")\n@classmethod\ndef deserialize_patterns(cls, values: List[Union[str, PatternType]]) -&gt; List[PatternType]:\n    \"\"\"Convert string patterns back to compiled regex.\"\"\"\n    return [regex.compile(v) if isinstance(v, str) else v for v in values]\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load settings from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to the settings file.</p> required <p>Returns:</p> Name Type Description <code>SettingsModel</code> <code>SettingsModel</code> <p>A new settings instance with the loaded configuration.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the settings file doesn't exist.</p> <code>JSONDecodeError</code> <p>If the settings file is corrupted or contains invalid JSON.</p> <code>ValidationError</code> <p>If the settings file contains invalid configuration.</p> Source code in <code>RTN/models.py</code> <pre><code>@classmethod\ndef load(cls, path: Union[str, Path]) -&gt; 'SettingsModel':\n    \"\"\"\n    Load settings from a JSON file.\n\n    Args:\n        path: Path to the settings file.\n\n    Returns:\n        SettingsModel: A new settings instance with the loaded configuration.\n\n    Raises:\n        FileNotFoundError: If the settings file doesn't exist.\n        JSONDecodeError: If the settings file is corrupted or contains invalid JSON.\n        ValidationError: If the settings file contains invalid configuration.\n    \"\"\"\n    path = Path(path)\n\n    if not path.exists():\n        raise FileNotFoundError(f\"Settings file not found: {path}\")\n\n    with path.open('r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    return cls.model_validate(data)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.load_or_default","title":"<code>load_or_default(path=None)</code>  <code>classmethod</code>","text":"<p>Load settings from a file if it exists, otherwise create default settings and save them.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Union[str, Path]]</code> <p>Optional path to the settings file. If None, returns default settings without saving.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SettingsModel</code> <code>SettingsModel</code> <p>Either the loaded settings or default settings.</p> <p>Raises:</p> Type Description <code>JSONDecodeError</code> <p>If the settings file is corrupted or contains invalid JSON.</p> Source code in <code>RTN/models.py</code> <pre><code>@classmethod\ndef load_or_default(cls, path: Optional[Union[str, Path]] = None) -&gt; 'SettingsModel':\n    \"\"\"\n    Load settings from a file if it exists, otherwise create default settings and save them.\n\n    Args:\n        path: Optional path to the settings file.\n            If None, returns default settings without saving.\n\n    Returns:\n        SettingsModel: Either the loaded settings or default settings.\n\n    Raises:\n        JSONDecodeError: If the settings file is corrupted or contains invalid JSON.\n    \"\"\"\n    if path is None:\n        return cls()\n\n    path = Path(path)\n    try:\n        return cls.load(path)\n    except FileNotFoundError:\n        settings = cls()\n        settings.save(path)\n        return settings\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.save","title":"<code>save(path)</code>","text":"<p>Save settings to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path where the settings file should be saved.  Can be either a string or Path object.</p> required Example <p>settings = SettingsModel() settings.save(\"my_settings.json\") settings.save(Path(\"configs/my_settings.json\"))</p> Source code in <code>RTN/models.py</code> <pre><code>def save(self, path: Union[str, Path]) -&gt; None:\n    \"\"\"\n    Save settings to a JSON file.\n\n    Args:\n        path: Path where the settings file should be saved.\n             Can be either a string or Path object.\n\n    Example:\n        &gt;&gt;&gt; settings = SettingsModel()\n        &gt;&gt;&gt; settings.save(\"my_settings.json\")\n        &gt;&gt;&gt; settings.save(Path(\"configs/my_settings.json\"))\n    \"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    with path.open('w', encoding='utf-8') as f:\n        json.dump(self.model_dump(mode='json'), f, indent=4)\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.SettingsModel.serialize_patterns","title":"<code>serialize_patterns(values)</code>","text":"<p>Convert regex patterns to strings for JSON serialization.</p> Source code in <code>RTN/models.py</code> <pre><code>@field_serializer(\"require\", \"exclude\", \"preferred\", when_used=\"always\")\ndef serialize_patterns(self, values: List[PatternType]) -&gt; List[str]:\n    \"\"\"Convert regex patterns to strings for JSON serialization.\"\"\"\n    return [v.pattern if isinstance(v, regex.Pattern) else v for v in values]\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.Torrent","title":"<code>Torrent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a torrent with metadata parsed from its title and additional computed properties.</p> <p>Attributes:</p> Name Type Description <code>`raw_title`</code> <code>str</code> <p>The original title of the torrent.</p> <code>`infohash`</code> <code>str</code> <p>The SHA-1 hash identifier of the torrent.</p> <code>`data`</code> <code>ParsedData</code> <p>Metadata extracted from the torrent title.</p> <code>`fetch`</code> <code>bool</code> <p>Indicates whether the torrent meets the criteria for fetching based on user settings.</p> <code>`rank`</code> <code>int</code> <p>The computed ranking score of the torrent based on user-defined preferences.</p> <code>`lev_ratio`</code> <code>float</code> <p>The Levenshtein ratio comparing the parsed title and the raw title for similarity.</p> <p>Methods:</p> Name Description <code>__eq__</code> <p>Determines equality based on the infohash of the torrent, allowing for easy comparison.</p> <code>__hash__</code> <p>Generates a hash based on the infohash of the torrent for set operations.</p> <p>Raises:</p> Type Description <code>`GarbageTorrent`</code> <p>If the title is identified as trash and should be ignored by the scraper.</p> Example <p>torrent = Torrent( ...     raw_title=\"The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]\", ...     infohash=\"c08a9ee8ce3a5c2c08865e2b05406273cabc97e7\", ...     data=ParsedData(...), ...     fetch=True, ...     rank=500, ...     lev_ratio=0.95, ... ) isinstance(torrent, Torrent) True torrent.raw_title 'The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]' torrent.infohash 'c08a9ee8ce3a5c2c08865e2b05406273cabc97e7' torrent.data.parsed_title 'The Walking Dead' torrent.fetch True torrent.rank 500 torrent.lev_ratio 0.95</p> Source code in <code>RTN/models.py</code> <pre><code>class Torrent(BaseModel):\n    \"\"\"\n    Represents a torrent with metadata parsed from its title and additional computed properties.\n\n    Attributes:\n        `raw_title` (str): The original title of the torrent.\n        `infohash` (str): The SHA-1 hash identifier of the torrent.\n        `data` (ParsedData): Metadata extracted from the torrent title.\n        `fetch` (bool): Indicates whether the torrent meets the criteria for fetching based on user settings.\n        `rank` (int): The computed ranking score of the torrent based on user-defined preferences.\n        `lev_ratio` (float): The Levenshtein ratio comparing the parsed title and the raw title for similarity.\n\n    Methods:\n        __eq__: Determines equality based on the infohash of the torrent, allowing for easy comparison.\n        __hash__: Generates a hash based on the infohash of the torrent for set operations.\n\n    Raises:\n        `GarbageTorrent`: If the title is identified as trash and should be ignored by the scraper.\n\n    Example:\n        &gt;&gt;&gt; torrent = Torrent(\n        ...     raw_title=\"The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]\",\n        ...     infohash=\"c08a9ee8ce3a5c2c08865e2b05406273cabc97e7\",\n        ...     data=ParsedData(...),\n        ...     fetch=True,\n        ...     rank=500,\n        ...     lev_ratio=0.95,\n        ... )\n        &gt;&gt;&gt; isinstance(torrent, Torrent)\n        True\n        &gt;&gt;&gt; torrent.raw_title\n        'The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]'\n        &gt;&gt;&gt; torrent.infohash\n        'c08a9ee8ce3a5c2c08865e2b05406273cabc97e7'\n        &gt;&gt;&gt; torrent.data.parsed_title\n        'The Walking Dead'\n        &gt;&gt;&gt; torrent.fetch\n        True\n        &gt;&gt;&gt; torrent.rank\n        500\n        &gt;&gt;&gt; torrent.lev_ratio\n        0.95\n    \"\"\"\n\n    infohash: str\n    raw_title: str\n    torrent: Optional[str] = None\n    seeders: Optional[int] = 0\n    leechers: Optional[int] = 0\n    trackers: Optional[List[str]] = []\n    data: ParsedData\n    fetch: bool = False\n    rank: int = 0\n    lev_ratio: float = 0.0\n\n    class Config:\n        from_attributes = True\n        use_orm = True\n        frozen = True\n\n    @field_validator(\"infohash\")\n    def validate_infohash(cls, v):\n        \"\"\"Validates infohash length and format (MD5 or SHA-1).\"\"\"\n        if len(v) not in (32, 40) or not INFOHASH_PATTERN.match(v):\n            raise GarbageTorrent(\"Infohash must be a 32-character MD5 hash or a 40-character SHA-1 hash.\")\n        return v\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Compares Torrent objects based on their infohash.\"\"\"\n        return isinstance(other, Torrent) and self.infohash == other.infohash\n\n    def __hash__(self) -&gt; int:\n        return hash(self.infohash)\n\n    def to_dict(self):\n        return self.model_dump_json()\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.Torrent.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares Torrent objects based on their infohash.</p> Source code in <code>RTN/models.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Compares Torrent objects based on their infohash.\"\"\"\n    return isinstance(other, Torrent) and self.infohash == other.infohash\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.Torrent.validate_infohash","title":"<code>validate_infohash(v)</code>","text":"<p>Validates infohash length and format (MD5 or SHA-1).</p> Source code in <code>RTN/models.py</code> <pre><code>@field_validator(\"infohash\")\ndef validate_infohash(cls, v):\n    \"\"\"Validates infohash length and format (MD5 or SHA-1).\"\"\"\n    if len(v) not in (32, 40) or not INFOHASH_PATTERN.match(v):\n        raise GarbageTorrent(\"Infohash must be a 32-character MD5 hash or a 40-character SHA-1 hash.\")\n    return v\n</code></pre>"},{"location":"devs/modules/models/#RTN.models.TrashRankModel","title":"<code>TrashRankModel</code>","text":"<p>               Bases: <code>ConfigModelBase</code></p> <p>Ranking configuration for trash attributes.</p> Source code in <code>RTN/models.py</code> <pre><code>class TrashRankModel(ConfigModelBase):\n    \"\"\"Ranking configuration for trash attributes.\"\"\"\n    cam: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    clean_audio: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    pdtv: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    r5: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    screener: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    size: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    telecine: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n    telesync: CustomRank = Field(default_factory=lambda: CustomRank(fetch=False))\n</code></pre>"},{"location":"devs/modules/parser/","title":"Parser","text":"<p>Parser module for parsing torrent titles and extracting metadata using RTN patterns.</p> <p>The module provides functions for parsing torrent titles, extracting metadata, and ranking torrents based on user preferences.</p> <p>Functions: - <code>parse</code>: Parse a torrent title and enrich it with additional metadata.</p> <p>Classes: - <code>Torrent</code>: Represents a torrent with metadata parsed from its title and additional computed properties. - <code>RTN</code>: Rank Torrent Name class for parsing and ranking torrent titles based on user preferences.</p> <p>Methods - <code>rank</code>: Parses a torrent title, computes its rank, and returns a Torrent object with metadata and ranking.</p> <p>For more information on each function or class, refer to the respective docstrings.</p>"},{"location":"devs/modules/parser/#RTN.parser.RTN","title":"<code>RTN</code>","text":"<p>RTN (Rank Torrent Name) class for parsing and ranking torrent titles based on user preferences.</p> <p>Parameters:</p> Name Type Description Default <code>`settings`</code> <code>SettingsModel</code> <p>The settings model with user preferences for parsing and ranking torrents.</p> required <code>`ranking_model`</code> <code>BaseRankingModel</code> <p>The model defining the ranking logic and score computation.</p> required Notes <ul> <li>The <code>settings</code> and <code>ranking_model</code> must be provided and must be valid instances of <code>SettingsModel</code> and <code>BaseRankingModel</code>.</li> <li>The <code>lev_threshold</code> is calculated from the <code>settings.options[\"title_similarity\"]</code> and is used to determine if a torrent title matches a correct title.</li> </ul> Example <pre><code>from RTN import RTN\nfrom RTN.models import SettingsModel, DefaultRanking\n\nsettings_model = SettingsModel()\nranking_model = DefaultRanking()\nrtn = RTN(settings_model, ranking_model)\n</code></pre> Source code in <code>RTN/parser.py</code> <pre><code>class RTN:\n    \"\"\"\n    RTN (Rank Torrent Name) class for parsing and ranking torrent titles based on user preferences.\n\n    Args:\n        `settings` (SettingsModel): The settings model with user preferences for parsing and ranking torrents.\n        `ranking_model` (BaseRankingModel): The model defining the ranking logic and score computation.\n\n    Notes:\n        - The `settings` and `ranking_model` must be provided and must be valid instances of `SettingsModel` and `BaseRankingModel`.\n        - The `lev_threshold` is calculated from the `settings.options[\"title_similarity\"]` and is used to determine if a torrent title matches a correct title.\n\n    Example:\n        ```python\n        from RTN import RTN\n        from RTN.models import SettingsModel, DefaultRanking\n\n        settings_model = SettingsModel()\n        ranking_model = DefaultRanking()\n        rtn = RTN(settings_model, ranking_model)\n        ```\n    \"\"\"\n\n    def __init__(self, settings: SettingsModel, ranking_model: Optional[BaseRankingModel] = None):\n        \"\"\"\n        Initializes the RTN class with settings and a ranking model.\n\n        Args:\n            `settings` (SettingsModel): The settings model with user preferences for parsing and ranking torrents.\n            `ranking_model` (BaseRankingModel): The model defining the ranking logic and score computation.\n\n        Raises:\n            ValueError: If settings or a ranking model is not provided.\n            TypeError: If settings is not an instance of SettingsModel or the ranking model is not an instance of BaseRankingModel.\n\n        Example:\n            ```python\n            from RTN import RTN\n            from RTN.models import SettingsModel, DefaultRanking\n\n            settings_model = SettingsModel()\n            ranking_model = DefaultRanking()\n            rtn = RTN(settings_model, ranking_model, lev_threshold=0.94)\n            ```\n        \"\"\"\n        self.settings = settings\n        self.ranking_model = ranking_model if ranking_model else DefaultRanking()\n        self.lev_threshold = self.settings.options.get(\"title_similarity\", 0.85)\n\n    def rank(self, raw_title: str, infohash: str, correct_title: str = \"\", remove_trash: bool = False, speed_mode: bool = True, **kwargs) -&gt; Torrent:\n        \"\"\"\n        Parses a torrent title, computes its rank, and returns a Torrent object with metadata and ranking.\n\n        Args:\n            `raw_title` (str): The original title of the torrent to parse.\n            `infohash` (str): The SHA-1 hash identifier of the torrent.\n            `correct_title` (str): The correct title to compare against for similarity. Defaults to an empty string.\n            `remove_trash` (bool): Whether to check for trash patterns and raise an error if found. Defaults to True.\n            `speed_mode` (bool): Whether to use speed mode for fetching. Defaults to True.\n\n        Returns:\n            Torrent: A Torrent object with metadata and ranking information.\n\n        Raises:\n            ValueError: If the title or infohash is not provided for any torrent.\n            TypeError: If the title or infohash is not a string.\n            GarbageTorrent: If the title is identified as trash and should be ignored by the scraper, or invalid SHA-1 infohash is given.\n\n        Notes:\n            - If `correct_title` is provided, the Levenshtein ratio will be calculated between the parsed title and the correct title.\n            - If the ratio is below the threshold, a `GarbageTorrent` error will be raised.\n            - If no correct title is provided, the Levenshtein ratio will be set to 0.0.\n\n        Example:\n            ```python\n            from RTN import RTN\n            from RTN.models import SettingsModel, DefaultRanking\n\n            settings_model = SettingsModel()\n            ranking_model = DefaultRanking()\n            rtn = RTN(settings_model, ranking_model)\n            torrent = rtn.rank(\"The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]\", \"c08a9ee8ce3a5c2c08865e2b05406273cabc97e7\")\n            assert isinstance(torrent, Torrent)\n            assert isinstance(torrent.data, ParsedData)\n            assert torrent.fetch\n            assert torrent.rank &gt; 0\n            assert torrent.lev_ratio &gt; 0.0\n            ```\n        \"\"\"\n        if not self.settings.enabled:\n            raise SettingsDisabled(\"Settings are disabled and cannot be used.\")\n\n        if not raw_title or not infohash:\n            raise ValueError(\"Both the title and infohash must be provided.\")\n\n        if len(infohash) != 40:\n            raise GarbageTorrent(\"The infohash must be a valid SHA-1 hash and 40 characters in length.\")\n\n        parsed_data: ParsedData = parse(raw_title)\n\n        lev_ratio = 0.0\n        if correct_title:\n            aliases = kwargs.get(\"aliases\", {})\n            lev_ratio: float = get_lev_ratio(correct_title, parsed_data.parsed_title, self.lev_threshold, aliases)\n            if remove_trash:\n                if lev_ratio &lt; self.lev_threshold:\n                    raise GarbageTorrent(f\"'{raw_title}' does not match the correct title. correct title: '{correct_title}', parsed title: '{parsed_data.parsed_title}'\")\n\n        is_fetchable, failed_keys = check_fetch(parsed_data, self.settings, speed_mode)\n        rank: int = get_rank(parsed_data, self.settings, self.ranking_model)\n\n        if remove_trash:\n            if not is_fetchable:\n                raise GarbageTorrent(f\"'{parsed_data.raw_title}' denied by: {', '.join(failed_keys)}\")\n\n            if rank &lt; self.settings.options[\"remove_ranks_under\"]:\n                raise GarbageTorrent(f\"'{raw_title}' does not meet the minimum rank requirement, got rank of {rank}\")\n\n        return Torrent(\n            infohash=infohash,\n            raw_title=raw_title,\n            data=parsed_data,\n            fetch=is_fetchable,\n            rank=rank,\n            lev_ratio=lev_ratio\n        )\n</code></pre>"},{"location":"devs/modules/parser/#RTN.parser.RTN.__init__","title":"<code>__init__(settings, ranking_model=None)</code>","text":"<p>Initializes the RTN class with settings and a ranking model.</p> <p>Parameters:</p> Name Type Description Default <code>`settings`</code> <code>SettingsModel</code> <p>The settings model with user preferences for parsing and ranking torrents.</p> required <code>`ranking_model`</code> <code>BaseRankingModel</code> <p>The model defining the ranking logic and score computation.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If settings or a ranking model is not provided.</p> <code>TypeError</code> <p>If settings is not an instance of SettingsModel or the ranking model is not an instance of BaseRankingModel.</p> Example <pre><code>from RTN import RTN\nfrom RTN.models import SettingsModel, DefaultRanking\n\nsettings_model = SettingsModel()\nranking_model = DefaultRanking()\nrtn = RTN(settings_model, ranking_model, lev_threshold=0.94)\n</code></pre> Source code in <code>RTN/parser.py</code> <pre><code>def __init__(self, settings: SettingsModel, ranking_model: Optional[BaseRankingModel] = None):\n    \"\"\"\n    Initializes the RTN class with settings and a ranking model.\n\n    Args:\n        `settings` (SettingsModel): The settings model with user preferences for parsing and ranking torrents.\n        `ranking_model` (BaseRankingModel): The model defining the ranking logic and score computation.\n\n    Raises:\n        ValueError: If settings or a ranking model is not provided.\n        TypeError: If settings is not an instance of SettingsModel or the ranking model is not an instance of BaseRankingModel.\n\n    Example:\n        ```python\n        from RTN import RTN\n        from RTN.models import SettingsModel, DefaultRanking\n\n        settings_model = SettingsModel()\n        ranking_model = DefaultRanking()\n        rtn = RTN(settings_model, ranking_model, lev_threshold=0.94)\n        ```\n    \"\"\"\n    self.settings = settings\n    self.ranking_model = ranking_model if ranking_model else DefaultRanking()\n    self.lev_threshold = self.settings.options.get(\"title_similarity\", 0.85)\n</code></pre>"},{"location":"devs/modules/parser/#RTN.parser.RTN.rank","title":"<code>rank(raw_title, infohash, correct_title='', remove_trash=False, speed_mode=True, **kwargs)</code>","text":"<p>Parses a torrent title, computes its rank, and returns a Torrent object with metadata and ranking.</p> <p>Parameters:</p> Name Type Description Default <code>`raw_title`</code> <code>str</code> <p>The original title of the torrent to parse.</p> required <code>`infohash`</code> <code>str</code> <p>The SHA-1 hash identifier of the torrent.</p> required <code>`correct_title`</code> <code>str</code> <p>The correct title to compare against for similarity. Defaults to an empty string.</p> required <code>`remove_trash`</code> <code>bool</code> <p>Whether to check for trash patterns and raise an error if found. Defaults to True.</p> required <code>`speed_mode`</code> <code>bool</code> <p>Whether to use speed mode for fetching. Defaults to True.</p> required <p>Returns:</p> Name Type Description <code>Torrent</code> <code>Torrent</code> <p>A Torrent object with metadata and ranking information.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the title or infohash is not provided for any torrent.</p> <code>TypeError</code> <p>If the title or infohash is not a string.</p> <code>GarbageTorrent</code> <p>If the title is identified as trash and should be ignored by the scraper, or invalid SHA-1 infohash is given.</p> Notes <ul> <li>If <code>correct_title</code> is provided, the Levenshtein ratio will be calculated between the parsed title and the correct title.</li> <li>If the ratio is below the threshold, a <code>GarbageTorrent</code> error will be raised.</li> <li>If no correct title is provided, the Levenshtein ratio will be set to 0.0.</li> </ul> Example <pre><code>from RTN import RTN\nfrom RTN.models import SettingsModel, DefaultRanking\n\nsettings_model = SettingsModel()\nranking_model = DefaultRanking()\nrtn = RTN(settings_model, ranking_model)\ntorrent = rtn.rank(\"The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]\", \"c08a9ee8ce3a5c2c08865e2b05406273cabc97e7\")\nassert isinstance(torrent, Torrent)\nassert isinstance(torrent.data, ParsedData)\nassert torrent.fetch\nassert torrent.rank &gt; 0\nassert torrent.lev_ratio &gt; 0.0\n</code></pre> Source code in <code>RTN/parser.py</code> <pre><code>def rank(self, raw_title: str, infohash: str, correct_title: str = \"\", remove_trash: bool = False, speed_mode: bool = True, **kwargs) -&gt; Torrent:\n    \"\"\"\n    Parses a torrent title, computes its rank, and returns a Torrent object with metadata and ranking.\n\n    Args:\n        `raw_title` (str): The original title of the torrent to parse.\n        `infohash` (str): The SHA-1 hash identifier of the torrent.\n        `correct_title` (str): The correct title to compare against for similarity. Defaults to an empty string.\n        `remove_trash` (bool): Whether to check for trash patterns and raise an error if found. Defaults to True.\n        `speed_mode` (bool): Whether to use speed mode for fetching. Defaults to True.\n\n    Returns:\n        Torrent: A Torrent object with metadata and ranking information.\n\n    Raises:\n        ValueError: If the title or infohash is not provided for any torrent.\n        TypeError: If the title or infohash is not a string.\n        GarbageTorrent: If the title is identified as trash and should be ignored by the scraper, or invalid SHA-1 infohash is given.\n\n    Notes:\n        - If `correct_title` is provided, the Levenshtein ratio will be calculated between the parsed title and the correct title.\n        - If the ratio is below the threshold, a `GarbageTorrent` error will be raised.\n        - If no correct title is provided, the Levenshtein ratio will be set to 0.0.\n\n    Example:\n        ```python\n        from RTN import RTN\n        from RTN.models import SettingsModel, DefaultRanking\n\n        settings_model = SettingsModel()\n        ranking_model = DefaultRanking()\n        rtn = RTN(settings_model, ranking_model)\n        torrent = rtn.rank(\"The Walking Dead S05E03 720p HDTV x264-ASAP[ettv]\", \"c08a9ee8ce3a5c2c08865e2b05406273cabc97e7\")\n        assert isinstance(torrent, Torrent)\n        assert isinstance(torrent.data, ParsedData)\n        assert torrent.fetch\n        assert torrent.rank &gt; 0\n        assert torrent.lev_ratio &gt; 0.0\n        ```\n    \"\"\"\n    if not self.settings.enabled:\n        raise SettingsDisabled(\"Settings are disabled and cannot be used.\")\n\n    if not raw_title or not infohash:\n        raise ValueError(\"Both the title and infohash must be provided.\")\n\n    if len(infohash) != 40:\n        raise GarbageTorrent(\"The infohash must be a valid SHA-1 hash and 40 characters in length.\")\n\n    parsed_data: ParsedData = parse(raw_title)\n\n    lev_ratio = 0.0\n    if correct_title:\n        aliases = kwargs.get(\"aliases\", {})\n        lev_ratio: float = get_lev_ratio(correct_title, parsed_data.parsed_title, self.lev_threshold, aliases)\n        if remove_trash:\n            if lev_ratio &lt; self.lev_threshold:\n                raise GarbageTorrent(f\"'{raw_title}' does not match the correct title. correct title: '{correct_title}', parsed title: '{parsed_data.parsed_title}'\")\n\n    is_fetchable, failed_keys = check_fetch(parsed_data, self.settings, speed_mode)\n    rank: int = get_rank(parsed_data, self.settings, self.ranking_model)\n\n    if remove_trash:\n        if not is_fetchable:\n            raise GarbageTorrent(f\"'{parsed_data.raw_title}' denied by: {', '.join(failed_keys)}\")\n\n        if rank &lt; self.settings.options[\"remove_ranks_under\"]:\n            raise GarbageTorrent(f\"'{raw_title}' does not meet the minimum rank requirement, got rank of {rank}\")\n\n    return Torrent(\n        infohash=infohash,\n        raw_title=raw_title,\n        data=parsed_data,\n        fetch=is_fetchable,\n        rank=rank,\n        lev_ratio=lev_ratio\n    )\n</code></pre>"},{"location":"devs/modules/parser/#RTN.parser.parse","title":"<code>parse(raw_title, translate_langs=False)</code>","text":"<p>Parses a torrent title using PTN and enriches it with additional metadata extracted from patterns.</p> <p>Parameters:</p> Name Type Description Default <code>- `raw_title`</code> <code>str</code> <p>The original torrent title to parse.</p> required <code>- `translate_langs`</code> <code>bool</code> <p>Whether to translate the language codes in the parsed title. Defaults to False.</p> required <code>- `json`</code> <code>bool</code> <p>Whether to return the parsed data as a dictionary. Defaults to False.</p> required <p>Returns:</p> Type Description <code>ParsedData</code> <p><code>ParsedData</code>: A data model containing the parsed metadata from the torrent title.</p> Example <pre><code>parsed_data = parse(\"Game of Thrones S08E06 1080p WEB-DL DD5.1 H264-GoT\")\nprint(parsed_data.parsed_title) # 'Game of Thrones'\nprint(parsed_data.normalized_title) # 'game of thrones'\nprint(parsed_data.type) # 'show'\nprint(parsed_data.seasons) # [8]\nprint(parsed_data.episodes) # [6]\nprint(parsed_data.resolution) # '1080p'\nprint(parsed_data.audio) # ['DD5.1']\nprint(parsed_data.codec) # 'H264'\n</code></pre> Source code in <code>RTN/parser.py</code> <pre><code>def parse(raw_title: str, translate_langs: bool = False) -&gt; ParsedData:\n    \"\"\"\n    Parses a torrent title using PTN and enriches it with additional metadata extracted from patterns.\n\n    Args:\n        - `raw_title` (str): The original torrent title to parse.\n        - `translate_langs` (bool): Whether to translate the language codes in the parsed title. Defaults to False.\n        - `json` (bool): Whether to return the parsed data as a dictionary. Defaults to False.\n\n    Returns:\n        `ParsedData`: A data model containing the parsed metadata from the torrent title.\n\n    Example:\n        ```python\n        parsed_data = parse(\"Game of Thrones S08E06 1080p WEB-DL DD5.1 H264-GoT\")\n        print(parsed_data.parsed_title) # 'Game of Thrones'\n        print(parsed_data.normalized_title) # 'game of thrones'\n        print(parsed_data.type) # 'show'\n        print(parsed_data.seasons) # [8]\n        print(parsed_data.episodes) # [6]\n        print(parsed_data.resolution) # '1080p'\n        print(parsed_data.audio) # ['DD5.1']\n        print(parsed_data.codec) # 'H264'\n        ```\n    \"\"\"\n    if not raw_title or not isinstance(raw_title, str):\n        raise TypeError(\"The input title must be a non-empty string.\")\n\n    data: Dict[str, Any] = parse_title(raw_title, translate_langs)\n    parsed_data: ParsedData = ParsedData(\n        **data,\n        raw_title=raw_title,\n        parsed_title=data.get(\"title\", \"\"),\n        normalized_title=normalize_title(data.get(\"title\", \"\")),\n        _3d=data.get(\"3d\", False)\n    )\n\n    return parsed_data\n</code></pre>"},{"location":"devs/modules/patterns/","title":"Patterns","text":"<p>This module contains additional parsing patterns and utilities that are used in RTN.</p> <p>Functions: - <code>normalize_title</code>: Normalize the title string to remove unwanted characters and patterns. - <code>check_pattern</code>: Check if a pattern is found in the input string.</p> <p>Arguments: - <code>patterns</code> (list[regex.Pattern]): A list of compiled regex patterns to check. - <code>raw_title</code> (str): The raw title string to check.</p> <p>For more information on each function, refer to the respective docstrings.</p>"},{"location":"devs/modules/patterns/#RTN.patterns.check_pattern","title":"<code>check_pattern(patterns, raw_title)</code>","text":"<p>Check if a pattern is found in the input string.</p> Source code in <code>RTN/patterns.py</code> <pre><code>def check_pattern(patterns: list[regex.Pattern], raw_title: str) -&gt; bool:\n    \"\"\"Check if a pattern is found in the input string.\"\"\"\n    return any(pattern.search(raw_title) for pattern in patterns)\n</code></pre>"},{"location":"devs/modules/patterns/#RTN.patterns.normalize_title","title":"<code>normalize_title(raw_title, lower=True)</code>","text":"<p>Normalize the title to remove special characters and accents.</p> Source code in <code>RTN/patterns.py</code> <pre><code>def normalize_title(raw_title: str, lower: bool = True) -&gt; str:\n    \"\"\"Normalize the title to remove special characters and accents.\"\"\"\n    translation_table = str.maketrans(translationTable)\n    lowered = raw_title.lower() if lower else raw_title\n    # Normalize unicode characters to their closest ASCII equivalent\n    normalized = unicodedata.normalize(\"NFKC\", lowered)\n    # Apply specific translations\n    translated = normalized.translate(translation_table)\n    # Remove punctuation\n    cleaned_title = \"\".join(c for c in translated if c.isalnum() or c.isspace())\n    return cleaned_title.strip()\n</code></pre>"},{"location":"devs/modules/ranker/","title":"Ranker","text":"<p>This module contains functions to rank parsed data based on user settings and custom ranking models.</p> <p>Functions: - <code>get_rank</code>: Calculate the ranking of the given parsed data. - <code>calculate_preferred</code>: Calculate the preferred ranking of a given parsed data. - <code>calculate_quality_rank</code>: Calculate the quality ranking of the given parsed data. - <code>calculate_codec_rank</code>: Calculate the codec ranking of the given parsed data. - <code>calculate_audio_rank</code>: Calculate the audio ranking of the given parsed data. - <code>calculate_extra_ranks</code>: Calculate all the other rankings of the given parsed data.</p> <p>Arguments: - <code>data</code> (ParsedData): The parsed data object containing information about the torrent title. - <code>settings</code> (SettingsModel): The user settings object containing custom ranking models. - <code>rank_model</code> (BaseRankingModel): The base ranking model used for calculating the ranking.</p> <p>For more information on each function, refer to the respective docstrings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_rank(ParsedData, SettingsModel, BaseRankingModel)\n250\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_audio_rank","title":"<code>calculate_audio_rank(data, settings, rank_model)</code>","text":"<p>Calculate the audio ranking of the given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_audio_rank(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"Calculate the audio ranking of the given parsed data.\"\"\"\n    if not data.audio:\n        return 0\n\n    total_rank = 0\n\n    for audio_format in data.audio:\n        match audio_format:\n            case \"AAC\":\n                total_rank += rank_model.aac if not settings.custom_ranks[\"audio\"][\"aac\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"aac\"].rank\n            case \"Atmos\":\n                total_rank += rank_model.atmos if not settings.custom_ranks[\"audio\"][\"atmos\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"atmos\"].rank\n            case \"Dolby Digital\":\n                total_rank += rank_model.dolby_digital if not settings.custom_ranks[\"audio\"][\"dolby_digital\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"dolby_digital\"].rank\n            case \"Dolby Digital Plus\":\n                total_rank += rank_model.dolby_digital_plus if not settings.custom_ranks[\"audio\"][\"dolby_digital_plus\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"dolby_digital_plus\"].rank\n            case \"DTS Lossy\":\n                total_rank += rank_model.dts_lossy if not settings.custom_ranks[\"audio\"][\"dts_lossy\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"dts_lossy\"].rank\n            case \"DTS Lossless\":\n                total_rank += rank_model.dts_lossless if not settings.custom_ranks[\"audio\"][\"dts_lossless\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"dts_lossless\"].rank\n            # case \"OPUS\":\n            #     total_rank += rank_model.opus if not settings.custom_ranks[\"audio\"][\"opus\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"opus\"].rank\n            # case \"PCM\":\n            #     total_rank += rank_model.pcm if not settings.custom_ranks[\"audio\"][\"pcm\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"pcm\"].rank\n            case \"FLAC\":\n                total_rank += rank_model.flac if not settings.custom_ranks[\"audio\"][\"flac\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"flac\"].rank\n            case \"MP3\":\n                total_rank += rank_model.mp3 if not settings.custom_ranks[\"audio\"][\"mp3\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"mp3\"].rank\n            case \"TrueHD\":\n                total_rank += rank_model.truehd if not settings.custom_ranks[\"audio\"][\"truehd\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"truehd\"].rank\n            case \"HQ Clean Audio\":\n                total_rank += rank_model.clean_audio if not settings.custom_ranks[\"trash\"][\"clean_audio\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"clean_audio\"].rank\n            case _:\n                total_rank += 0\n\n    return total_rank\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_channels_rank","title":"<code>calculate_channels_rank(data, settings, rank_model)</code>","text":"<p>Calculate the channels ranking of the given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_channels_rank(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"Calculate the channels ranking of the given parsed data.\"\"\"\n    if not data.channels:\n        return 0\n\n    total_rank = 0\n    for channel in data.channels:\n        match channel:\n            case \"5.1\" | \"7.1\":\n                total_rank += rank_model.surround if not settings.custom_ranks[\"audio\"][\"surround\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"surround\"].rank\n            case \"stereo\" | \"2.0\":\n                total_rank += rank_model.stereo if not settings.custom_ranks[\"audio\"][\"stereo\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"stereo\"].rank\n            case \"mono\":\n                total_rank += rank_model.mono if not settings.custom_ranks[\"audio\"][\"mono\"].use_custom_rank else settings.custom_ranks[\"audio\"][\"mono\"].rank\n            case _:\n                total_rank += 0\n\n    return total_rank\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_codec_rank","title":"<code>calculate_codec_rank(data, settings, rank_model)</code>","text":"<p>Calculate the codec ranking of the given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_codec_rank(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"Calculate the codec ranking of the given parsed data.\"\"\"\n    if not data.codec:\n        return 0\n\n    codec = data.codec.lower()\n    match codec:\n        case \"avc\":\n            return rank_model.avc if not settings.custom_ranks[\"quality\"][\"avc\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"avc\"].rank\n        case \"hevc\":\n            return rank_model.hevc if not settings.custom_ranks[\"quality\"][\"hevc\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"hevc\"].rank\n        case \"xvid\":\n            return rank_model.xvid if not settings.custom_ranks[\"quality\"][\"xvid\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"xvid\"].rank\n        case \"av1\":\n            return rank_model.av1 if not settings.custom_ranks[\"quality\"][\"av1\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"av1\"].rank\n        case \"mpeg\":\n            return rank_model.mpeg if not settings.custom_ranks[\"quality\"][\"mpeg\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"mpeg\"].rank\n        case _:\n            return 0\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_extra_ranks","title":"<code>calculate_extra_ranks(data, settings, rank_model)</code>","text":"<p>Calculate all the other rankings of the given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_extra_ranks(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"Calculate all the other rankings of the given parsed data.\"\"\"\n    if not data.bit_depth and not data.hdr and not data.seasons and not data.episodes:\n        return 0\n\n    total_rank = 0\n\n    if data._3d:\n        total_rank += rank_model.remux if not settings.custom_ranks[\"extras\"][\"three_d\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"three_d\"].rank\n    if data.converted:\n        total_rank += rank_model.converted if not settings.custom_ranks[\"extras\"][\"converted\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"converted\"].rank\n    if data.documentary:\n        total_rank += rank_model.documentary if not settings.custom_ranks[\"extras\"][\"documentary\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"documentary\"].rank\n    if data.dubbed:\n        total_rank += rank_model.dubbed if not settings.custom_ranks[\"extras\"][\"dubbed\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"dubbed\"].rank\n    if data.edition:\n        total_rank += rank_model.edition if not settings.custom_ranks[\"extras\"][\"edition\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"edition\"].rank\n    if data.hardcoded:\n        total_rank += rank_model.hardcoded if not settings.custom_ranks[\"extras\"][\"hardcoded\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"hardcoded\"].rank\n    if data.network:\n        total_rank += rank_model.network if not settings.custom_ranks[\"extras\"][\"network\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"network\"].rank\n    if data.proper:\n        total_rank += rank_model.proper if not settings.custom_ranks[\"extras\"][\"proper\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"proper\"].rank\n    if data.repack:\n        total_rank += rank_model.repack if not settings.custom_ranks[\"extras\"][\"repack\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"repack\"].rank\n    if data.retail:\n        total_rank += rank_model.retail if not settings.custom_ranks[\"extras\"][\"retail\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"retail\"].rank\n    if data.subbed:\n        total_rank += rank_model.subbed if not settings.custom_ranks[\"extras\"][\"subbed\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"subbed\"].rank\n    if data.upscaled:\n        total_rank += rank_model.upscaled if not settings.custom_ranks[\"extras\"][\"upscaled\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"upscaled\"].rank\n    if data.site:\n        total_rank += rank_model.site if not settings.custom_ranks[\"extras\"][\"site\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"site\"].rank\n    if data.size:\n        total_rank += rank_model.size if not settings.custom_ranks[\"trash\"][\"size\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"size\"].rank\n    if data.scene:\n        total_rank += rank_model.scene if not settings.custom_ranks[\"extras\"][\"scene\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"scene\"].rank\n    if data.uncensored:\n        total_rank += rank_model.uncensored if not settings.custom_ranks[\"extras\"][\"uncensored\"].use_custom_rank else settings.custom_ranks[\"extras\"][\"uncensored\"].rank\n    return total_rank\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_hdr_rank","title":"<code>calculate_hdr_rank(data, settings, rank_model)</code>","text":"<p>Calculate the codec ranking of the given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_hdr_rank(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"Calculate the codec ranking of the given parsed data.\"\"\"\n    if not data.hdr:\n        return 0\n\n    total_rank = 0\n    for hdr in data.hdr:\n        match hdr:\n            case \"DV\":\n                total_rank += rank_model.dolby_vision if not settings.custom_ranks[\"hdr\"][\"dolby_vision\"].use_custom_rank else settings.custom_ranks[\"hdr\"][\"dolby_vision\"].rank\n            case \"HDR\":\n                total_rank += rank_model.hdr if not settings.custom_ranks[\"hdr\"][\"hdr\"].use_custom_rank else settings.custom_ranks[\"hdr\"][\"hdr\"].rank\n            case \"HDR10+\":\n                total_rank += rank_model.hdr10plus if not settings.custom_ranks[\"hdr\"][\"hdr10plus\"].use_custom_rank else settings.custom_ranks[\"hdr\"][\"hdr10plus\"].rank\n            case \"SDR\":\n                total_rank += rank_model.sdr if not settings.custom_ranks[\"hdr\"][\"sdr\"].use_custom_rank else settings.custom_ranks[\"hdr\"][\"sdr\"].rank\n            case _:\n                total_rank += 0\n\n    if data.bit_depth:\n        total_rank += rank_model.bit_10 if not settings.custom_ranks[\"hdr\"][\"10bit\"].use_custom_rank else settings.custom_ranks[\"hdr\"][\"10bit\"].rank\n\n    return total_rank\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_preferred","title":"<code>calculate_preferred(data, settings)</code>","text":"<p>Calculate the preferred ranking of a given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_preferred(data: ParsedData, settings: SettingsModel) -&gt; int:\n    \"\"\"Calculate the preferred ranking of a given parsed data.\"\"\"\n    if not settings.preferred or all(pattern is None for pattern in settings.preferred):\n        return 0\n    return 10000 if any(regex.search(pattern, data.raw_title) for pattern in settings.preferred if pattern) else 0\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_preferred_langs","title":"<code>calculate_preferred_langs(data, settings)</code>","text":"<p>Calculate the preferred languages ranking of a given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_preferred_langs(data: ParsedData, settings: SettingsModel) -&gt; int:\n    \"\"\"Calculate the preferred languages ranking of a given parsed data.\"\"\"\n    if not settings.languages[\"preferred\"]:\n        return 0\n    return 10000 if any(lang in data.languages for lang in settings.languages[\"preferred\"]) else 0\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.calculate_quality_rank","title":"<code>calculate_quality_rank(data, settings, rank_model)</code>","text":"<p>Calculate the quality ranking of the given parsed data.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def calculate_quality_rank(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"Calculate the quality ranking of the given parsed data.\"\"\"\n    if not data.quality:\n        return 0\n\n    quality = data.quality\n    match quality:\n        # Quality\n        case \"WEB\":\n            return rank_model.web if not settings.custom_ranks[\"quality\"][\"web\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"web\"].rank\n        case \"WEB-DL\":\n            return rank_model.webdl if not settings.custom_ranks[\"quality\"][\"webdl\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"webdl\"].rank\n        case \"BluRay\":\n            return rank_model.bluray if not settings.custom_ranks[\"quality\"][\"bluray\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"bluray\"].rank\n        case \"HDTV\":\n            return rank_model.hdtv if not settings.custom_ranks[\"quality\"][\"hdtv\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"hdtv\"].rank\n        case \"VHS\":\n            return rank_model.vhs if not settings.custom_ranks[\"quality\"][\"vhs\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"vhs\"].rank\n        case \"WEBMux\":\n            return rank_model.webmux if not settings.custom_ranks[\"quality\"][\"webmux\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"webmux\"].rank\n        case \"BluRay REMUX\" | \"REMUX\":\n            return rank_model.remux if not settings.custom_ranks[\"quality\"][\"remux\"].use_custom_rank else settings.custom_ranks[\"quality\"][\"remux\"].rank\n\n        # Rips\n        case \"WEBRip\":\n            return rank_model.webrip if not settings.custom_ranks[\"rips\"][\"webrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"webrip\"].rank\n        case \"WEB-DLRip\":\n            return rank_model.webdlrip if not settings.custom_ranks[\"rips\"][\"webdlrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"webdlrip\"].rank\n        case \"UHDRip\":\n            return rank_model.uhdrip if not settings.custom_ranks[\"rips\"][\"uhdrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"uhdrip\"].rank\n        case \"HDRip\":\n            return rank_model.hdrip if not settings.custom_ranks[\"rips\"][\"hdrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"hdrip\"].rank\n        case \"DVDRip\":\n            return rank_model.dvdrip if not settings.custom_ranks[\"rips\"][\"dvdrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"dvdrip\"].rank\n        case \"BDRip\":\n            return rank_model.bdrip if not settings.custom_ranks[\"rips\"][\"bdrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"bdrip\"].rank\n        case \"BRRip\":\n            return rank_model.brrip if not settings.custom_ranks[\"rips\"][\"brrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"brrip\"].rank\n        case \"VHSRip\":\n            return rank_model.vhsrip if not settings.custom_ranks[\"rips\"][\"vhsrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"vhsrip\"].rank\n        case \"PPVRip\":\n            return rank_model.ppvrip if not settings.custom_ranks[\"rips\"][\"ppvrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"ppvrip\"].rank\n        case \"SATRip\":\n            return rank_model.satrip if not settings.custom_ranks[\"rips\"][\"satrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"satrip\"].rank\n        case \"TVRip\":\n            return rank_model.tvrip if not settings.custom_ranks[\"rips\"][\"tvrip\"].use_custom_rank else settings.custom_ranks[\"rips\"][\"tvrip\"].rank\n\n        # Trash\n        case \"TeleCine\":\n            return rank_model.telecine if not settings.custom_ranks[\"trash\"][\"telecine\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"telecine\"].rank\n        case \"TeleSync\":\n            return rank_model.telesync if not settings.custom_ranks[\"trash\"][\"telesync\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"telesync\"].rank\n        case \"SCR\":\n            return rank_model.screener if not settings.custom_ranks[\"trash\"][\"screener\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"screener\"].rank\n        case \"R5\":\n            return rank_model.r5 if not settings.custom_ranks[\"trash\"][\"r5\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"r5\"].rank\n        case \"CAM\":\n            return rank_model.cam if not settings.custom_ranks[\"trash\"][\"cam\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"cam\"].rank\n        case \"PDTV\":\n            return rank_model.pdtv if not settings.custom_ranks[\"trash\"][\"pdtv\"].use_custom_rank else settings.custom_ranks[\"trash\"][\"pdtv\"].rank\n        case _:\n            return 0\n</code></pre>"},{"location":"devs/modules/ranker/#RTN.ranker.get_rank","title":"<code>get_rank(data, settings, rank_model)</code>","text":"<p>Calculate the ranking of the given parsed data.</p> <p>Parameters:</p> Name Type Description Default <code>`data`</code> <code>ParsedData</code> <p>The parsed data object containing information about the torrent title.</p> required <code>`settings`</code> <code>SettingsModel</code> <p>The user settings object containing custom ranking models.</p> required <code>`rank_model`</code> <code>BaseRankingModel</code> <p>The base ranking model used for calculating the ranking.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The calculated ranking value for the parsed data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the parsed data is empty.</p> <code>TypeError</code> <p>If the parsed data is not a ParsedData object.</p> Source code in <code>RTN/ranker.py</code> <pre><code>def get_rank(data: ParsedData, settings: SettingsModel, rank_model: BaseRankingModel) -&gt; int:\n    \"\"\"\n    Calculate the ranking of the given parsed data.\n\n    Parameters:\n        `data` (ParsedData): The parsed data object containing information about the torrent title.\n        `settings` (SettingsModel): The user settings object containing custom ranking models.\n        `rank_model` (BaseRankingModel): The base ranking model used for calculating the ranking.\n\n    Returns:\n        int: The calculated ranking value for the parsed data.\n\n    Raises:\n        ValueError: If the parsed data is empty.\n        TypeError: If the parsed data is not a ParsedData object.\n    \"\"\"\n    if not isinstance(data, ParsedData):\n        raise TypeError(\"Parsed data must be an instance of ParsedData.\")\n    if not data.raw_title:\n        raise ValueError(\"Parsed data cannot be empty.\")\n\n    rank: int = 0\n    rank += calculate_quality_rank(data, settings, rank_model)\n    rank += calculate_hdr_rank(data, settings, rank_model)\n    rank += calculate_channels_rank(data, settings, rank_model)\n    rank += calculate_audio_rank(data, settings, rank_model)\n    rank += calculate_codec_rank(data, settings, rank_model)\n    rank += calculate_extra_ranks(data, settings, rank_model)\n    rank += calculate_preferred(data, settings)\n    rank += calculate_preferred_langs(data, settings)\n    return rank\n</code></pre>"},{"location":"users/faq/","title":"Frequently Asked Questions","text":""},{"location":"users/faq/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<ul> <li>Set <code>require</code> and <code>exclude</code> patterns to filter torrents</li> <li>Adjust <code>resolutions</code> and <code>languages</code> to match your preferences</li> <li>Fine-tune with <code>custom_ranks</code> for advanced control</li> </ul>"},{"location":"users/faq/#filtering-settings","title":"\ud83d\udd0d Filtering Settings","text":""},{"location":"users/faq/#how-do-i-use-the-require-exclude-and-preferred-settings","title":"How do I use the \"require\", \"exclude\", and \"preferred\" settings?","text":"<p>A: These settings allow you to specify patterns (using simple strings or regular expressions) to filter and prioritize torrents:</p> <ol> <li> <p>require: Patterns that must be present in a torrent name for it to be considered.</p> <pre><code>require = [\"1080p\", \"\\\\b202[0-3]\\\\b\"]\n</code></pre> <p>This would only consider 1080p content with a year between 2020 and 2023.</p> </li> <li> <p>exclude: Patterns that, if present, will cause a torrent to be ignored.</p> <pre><code>exclude = [\"CAM\", \"LQ|LOW.?QUALITY\"]\n</code></pre> <p>This would exclude CAM releases and those with \"LQ\" or \"LOW QUALITY\" in the name.</p> <p>This is one example but CAM releases are already parsed out by default, so this won't be needed.</p> </li> <li> <p>preferred: Patterns that, if present, will give a torrent higher priority in ranking.</p> <pre><code>preferred = [\"BluRay\", \"SPARKS|AMIABLE|GECKOS\"]\n</code></pre> <p>This would prefer BluRay releases and those from specific groups <code>SPARKS</code>, <code>AMIABLE</code> or <code>GECKOS</code>.</p> </li> </ol> <p>All these settings support both simple string matching and more complex regular expressions, allowing for flexible and powerful torrent filtering and prioritization.</p>"},{"location":"users/faq/#resolution-settings","title":"\ud83c\udfac Resolution Settings","text":""},{"location":"users/faq/#how-do-i-control-which-resolutions-are-accepted","title":"How do I control which resolutions are accepted?","text":"<p>A: The \"resolutions\" setting allows you to specify which resolutions you want to accept. Set the value to True for resolutions you want to include, and False for those you want to exclude.</p>"},{"location":"users/faq/#how-does-sorting-work-for-resolutions","title":"How does sorting work for resolutions?","text":"<p>A: Torrents are sorted into resolution buckets, with higher resolutions given higher priority. The order of priority is typically:</p> <ol> <li>2160p (4K)</li> <li>1080p</li> <li>720p</li> <li>480p</li> <li>360p</li> <li>Unknown resolution</li> </ol> <p>Within each resolution bucket, torrents are then sorted by their rank in descending order. This means that for each resolution category, the highest-ranked torrents appear first. If a torrent doesn't have a rank, it's treated as having an unknown rank and placed at the bottom of its resolution group.</p> <p>This sorting method ensures that you get the best quality options within your preferred resolution ranges, making it easier to select the most suitable torrent for your needs.</p>"},{"location":"users/faq/#language-settings","title":"\ud83c\udf10 Language Settings","text":""},{"location":"users/faq/#how-do-i-set-my-language-preferences","title":"How do I set my language preferences?","text":"<p>A: The \"languages\" setting has three sub-settings: - <code>required</code>: List 2-character language codes that must be present. - <code>exclude</code>: List 2-character language codes you don't want. - <code>preferred</code>: List 2-character language codes you prefer.</p> <p>Example: <code>[\"es\", \"de\", \"fr\", \"ja\"]</code></p> <p>There is a few preset language codes you can use as well:   - <code>any</code>: This will include all languages.   - <code>common</code>: This will include common languages like English, Spanish, French, Japanese, etc.   - <code>anime</code>: This will include anime languages. (<code>ja</code>, <code>en</code>, <code>zh</code>)   - <code>nonanime</code>: This will include non-anime languages. (<code>en</code>, <code>zh</code>)</p> <p>All language preferences use ISO 639-1 two-letter language codes.</p> <p>If you want to exclude all languages, regardless of language preferences, set this to <code>[\"any\"]</code></p>"},{"location":"users/faq/#options-settings","title":"\u2699\ufe0f Options Settings","text":""},{"location":"users/faq/#what-does-the-title_similarity-option-do","title":"What does the \"title_similarity\" option do?","text":"<p>A: The <code>title_similarity</code> option (default 0.85) sets how closely a torrent's title must match the expected title. A higher value (closer to 1.0) requires a more exact match.</p> <p>Titles are normalized to remove special characters and extra whitespace, so a value of <code>0.85</code> is quite lenient!</p> <p>If you want to include all torrents, regardless of title similarity, set this to <code>0</code>, however anything below <code>0.85</code> will include terrible results!</p>"},{"location":"users/faq/#what-is-the-remove_all_trash-option","title":"What is the \"remove_all_trash\" option?","text":"<p>A: When set to True, the <code>remove_all_trash</code> option (default True) automatically filters out torrents considered low quality or \"trash\" based on predefined criteria.</p> <p>This excludes torrents with indicators of poor quality or undesirable sources, such as:</p> <ul> <li>CAM, TS (TeleSYNC), TC (TeleCINE) releases</li> <li>Screener or SCR versions</li> <li>Pre-DVD releases</li> <li>DVB-Rip and SAT-Rip sources</li> <li>R5/R6 releases</li> <li>Leaked versions</li> <li>Deleted scenes</li> <li>HQ audio cleanups</li> </ul> <p>For more information on the trash regex, see Parsett Trash Regex. These filters help ensure that only higher quality releases are considered, improving the overall quality of your media collection.</p>"},{"location":"users/faq/#how-does-the-remove_ranks_under-option-work","title":"How does the \"remove_ranks_under\" option work?","text":"<p>A: The <code>remove_ranks_under</code> option (default -10000) sets a minimum rank threshold. Torrents ranked below this value will be excluded from results.</p> <p>Bonus tip! If you want to exclude torrents that don't get ranked or have a negative rank, you can set this to <code>0</code>. Ensuring you only get positive ranked torrents in your results.</p>"},{"location":"users/faq/#what-does-remove_unknown_languages-do","title":"What does \"remove_unknown_languages\" do?","text":"<p>A: When set to True, the <code>remove_unknown_languages</code> option (default False) will exclude torrents that don't have a language in the title.</p>"},{"location":"users/faq/#what-is-the-purpose-of-allow_english_in_languages","title":"What is the purpose of \"allow_english_in_languages\"?","text":"<p>A: The <code>allow_english_in_languages</code> option (default False), when set to True, allows English language torrents to be included even if a user has excluded English from their language preferences. This can be useful for users who want to prioritize content in specific languages but still want access to English-language releases if they're available alongside their preferred languages. It essentially bypasses the language exclusion for English, ensuring that multilingual torrents containing English aren't filtered out due to strict language settings.</p> <p>One scenario is if you wanted a movie that's released in Spanish, and you excluded the Spanish language, but you still want to include it if it's in English as well. This setting works great for Anime as well that you want to include if it's in English as well.</p>"},{"location":"users/faq/#custom-ranks","title":"\ud83c\udfc6 Custom Ranks","text":""},{"location":"users/faq/#how-do-i-use-custom-ranks","title":"How do I use custom ranks?","text":"<p>A: Custom ranks allow you to assign specific values to various attributes of torrents. </p> Setting Type Description <code>fetch</code> Boolean Determines if the attribute should be picked or not <code>use_custom_rank</code> Boolean Enables or disables the use of a custom rank <code>rank</code> Number Sets the importance of the attribute <p>Boolean's are pretty simple, if you want the attribute, set it to <code>True</code>, if you don't, set it to <code>False</code></p> <p>Ranks are additive, so a higher rank will be prioritized over a lower rank. You can use this to your advantage to fine tune the torrents that are picked up. </p> <p>How's it work?</p> <ul> <li>If <code>fetch</code> is set to <code>False</code>, this is equivalent to saying you don't want that attribute in the title.</li> <li>You can set a negative rank to subtract from the overall rank. This is useful if you want to ignore certain torrents. Example: <code>-100</code> will be subtracted from the overall rank.</li> <li>Rankings for individual attributes accumulate. If a file matches three attributes with individual rankings of 100, the overall rank of that file will be 300. Then they are sorted by their overall score.</li> </ul>"},{"location":"users/faq/#can-i-prioritize-certain-audio-or-video-codecs","title":"Can I prioritize certain audio or video codecs?","text":"<p>A: Yes! In the <code>custom_ranks</code> section, you can adjust the rank values for different codecs. Higher rank values will be prioritized.</p> <p>Remember, these settings allow you to fine-tune RTN to your specific preferences. Don't be afraid to experiment with different configurations to find what works best for you!</p>"},{"location":"users/faq/#how-high-or-low-can-i-set-the-ranks","title":"How high or low can I set the ranks?","text":"<p>A: You have complete flexibility when it comes to setting ranks in RTN. There are no strict upper or lower limits on the rank values you can use. You can set ranks to any integer value, positive or negative, that suits your needs. This allows for a wide range of customization:</p> <ul> <li>You can use small, single-digit numbers (like 1, 2, 3) for subtle differences.</li> <li>You can use larger numbers (like 100, 500, 1000) for more significant distinctions.</li> <li>You can even use very large numbers (like 10000, 50000, 100000) if you want extreme prioritization.</li> <li>Negative numbers are also valid, allowing you to penalize certain attributes.</li> </ul> <p>The key is to choose a scale that makes sense for your specific use case. For example:</p> <ul> <li>If you're making fine distinctions, you might use a scale from -10 to +10.</li> <li>For broader categories, you might use -1000 to +1000.</li> <li>If you want certain attributes to always outweigh others, you might use values in the tens of thousands.</li> </ul> <p>Remember, ranks are additive, so consider how they'll interact when multiple attributes are present. Experiment with different scales to find what works best for your specific needs and preferences.</p>"},{"location":"users/faq/#whats-the-best-way-to-get-started-with-custom-ranks","title":"What's the best way to get started with custom ranks?","text":"<p>A: The best way to get started with custom ranks is to look at a few filenames that you would prefer and rank those attributes higher than others. For instance:</p> <ol> <li>Identify your preferred qualities: If you want HDR or REMUX versions, you would rank these attributes higher.</li> <li>Assign higher ranks: Give these preferred attributes (like HDR or REMUX) higher rank values compared to lower quality options.</li> <li>Fine-tune: Adjust other attributes based on your preferences, giving lower ranks to less desirable qualities.</li> </ol> <p>Remember, the goal is to create a ranking system that prioritizes the qualities you value most in your media files.</p>"},{"location":"users/languages/","title":"Language Support in RTN","text":"<p>We use ISO 639-1 two-letter language codes to manage language preferences. This standardization allows for precise control over language-related settings in your torrent ranking and filtering processes.</p>"},{"location":"users/languages/#supported-languages","title":"Supported Languages","text":"<p>Below is a comprehensive list of languages supported by RTN, along with their corresponding ISO 639-1 codes:</p> Code Language Code Language Code Language <code>ar</code> Arabic <code>fr</code> French <code>ml</code> Malayalam <code>bn</code> Bengali <code>de</code> German <code>mr</code> Marathi <code>bg</code> Bulgarian <code>el</code> Greek <code>ms</code> Malay <code>zh</code> Chinese <code>gu</code> Gujarati <code>no</code> Norwegian <code>hr</code> Croatian <code>he</code> Hebrew <code>fa</code> Persian <code>cs</code> Czech <code>hi</code> Hindi <code>pl</code> Polish <code>da</code> Danish <code>hu</code> Hungarian <code>pt</code> Portuguese <code>nl</code> Dutch <code>id</code> Indonesian <code>pa</code> Punjabi <code>en</code> English <code>it</code> Italian <code>ro</code> Romanian <code>et</code> Estonian <code>ja</code> Japanese <code>ru</code> Russian <code>fi</code> Finnish <code>kn</code> Kannada <code>sr</code> Serbian <code>ko</code> Korean <code>la</code> Latin <code>sk</code> Slovak <code>lv</code> Latvian <code>lt</code> Lithuanian <code>sl</code> Slovenian <code>es</code> Spanish <code>sv</code> Swedish <code>ta</code> Tamil <code>te</code> Telugu <code>th</code> Thai <code>tr</code> Turkish <code>uk</code> Ukrainian <code>vi</code> Vietnamese"},{"location":"users/languages/#using-language-codes-in-rtn","title":"Using Language Codes in RTN","text":"<p>When configuring RTN, you can use these language codes to:</p> <ol> <li>Set preferred languages for torrent selection</li> <li>Exclude specific languages from your search results</li> </ol>"}]}